<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>狼人杀游戏</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <script src="https://unpkg.com/peerjs@1.4.7/dist/peerjs.min.js"></script>
    <script>
        tailwind.config = {
            darkMode: 'class',
            theme: {
                extend: {
                    colors: {
                        primary: '#5D5CDE',
                        wolf: '#BB2D3B',
                        villager: '#198754',
                        night: '#0F172A',
                        day: '#F8FAFC'
                    }
                }
            }
        }
    </script>
    <style>
        /* 自定义样式 */
        .role-card {
            perspective: 1000px;
            height: 140px;
            width: 100px;
        }
        .role-card-inner {
            position: relative;
            width: 100%;
            height: 100%;
            transition: transform 0.6s;
            transform-style: preserve-3d;
        }
        .role-card.flipped .role-card-inner {
            transform: rotateY(180deg);
        }
        .role-card-front, .role-card-back {
            position: absolute;
            width: 100%;
            height: 100%;
            backface-visibility: hidden;
            border-radius: 0.5rem;
        }
        .role-card-back {
            transform: rotateY(180deg);
        }
        
        /* 动画 */
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        .fade-in {
            animation: fadeIn 0.5s ease-in;
        }
        
        /* 夜晚滤镜 */
        .night-filter {
            background-color: rgba(15, 23, 42, 0.5);
            backdrop-filter: brightness(0.7) saturate(0.8);
        }
        
        /* 黑暗模式支持 */
        .dark .bg-white {
            background-color: #181818;
        }
        .dark .bg-gray-100 {
            background-color: #1e1e1e;
        }
        .dark .text-gray-700 {
            color: #d1d5db;
        }
        .dark .text-gray-800 {
            color: #e5e7eb;
        }
        .dark .text-gray-600 {
            color: #9ca3af;
        }
        .dark .border-gray-200 {
            border-color: #2d2d2d;
        }
        .dark .shadow {
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.5);
        }
        
        /* 发言轮次指示器 */
        .speaking-indicator {
            animation: pulse 2s infinite;
        }
        @keyframes pulse {
            0% { box-shadow: 0 0 0 0 rgba(93, 92, 222, 0.7); }
            70% { box-shadow: 0 0 0 10px rgba(93, 92, 222, 0); }
            100% { box-shadow: 0 0 0 0 rgba(93, 92, 222, 0); }
        }
    </style>
</head>
<body class="bg-gray-100 min-h-screen dark:bg-gray-900 dark:text-white transition-colors duration-200">
    <div id="app" class="container mx-auto px-4 py-8 max-w-4xl">
        <!-- 欢迎屏幕 -->
        <div id="welcome-screen" class="fade-in">
            <h1 class="text-3xl font-bold text-center mb-8">🐺 狼人杀游戏 🌙</h1>
            <div class="bg-white dark:bg-gray-800 rounded-lg shadow-lg p-6 mb-6">
                <h2 class="text-xl font-semibold mb-4">开始游戏</h2>
                <div class="flex flex-col md:flex-row gap-4">
                    <div class="flex-1 border border-gray-200 dark:border-gray-700 rounded-lg p-4">
                        <h3 class="font-medium mb-3">创建房间</h3>
                        <div class="mb-4">
                            <label for="player-name-create" class="block mb-2 text-sm font-medium">你的名字</label>
                            <input type="text" id="player-name-create" class="w-full px-3 py-2 text-base border rounded-md focus:outline-none focus:ring-2 focus:ring-primary dark:bg-gray-700 dark:border-gray-600" placeholder="输入你的名字">
                        </div>
                        <button id="create-room-btn" class="w-full bg-primary hover:bg-indigo-600 text-white font-medium py-2 px-4 rounded-md transition">创建房间</button>
                    </div>
                    <div class="flex-1 border border-gray-200 dark:border-gray-700 rounded-lg p-4">
                        <h3 class="font-medium mb-3">加入房间</h3>
                        <div class="mb-4">
                            <label for="player-name-join" class="block mb-2 text-sm font-medium">你的名字</label>
                            <input type="text" id="player-name-join" class="w-full px-3 py-2 text-base border rounded-md focus:outline-none focus:ring-2 focus:ring-primary dark:bg-gray-700 dark:border-gray-600" placeholder="输入你的名字">
                        </div>
                        <div class="mb-4">
                            <label for="room-code" class="block mb-2 text-sm font-medium">房间代码</label>
                            <input type="text" id="room-code" class="w-full px-3 py-2 text-base border rounded-md focus:outline-none focus:ring-2 focus:ring-primary dark:bg-gray-700 dark:border-gray-600" placeholder="输入房间代码">
                        </div>
                        <button id="join-room-btn" class="w-full bg-primary hover:bg-indigo-600 text-white font-medium py-2 px-4 rounded-md transition">加入房间</button>
                    </div>
                </div>
            </div>
            
            <div class="bg-white dark:bg-gray-800 rounded-lg shadow-lg p-6">
                <h2 class="text-xl font-semibold mb-4">游戏规则</h2>
                <div class="prose dark:prose-invert max-w-none">
                    <p>狼人杀是一个充满乐趣的推理游戏，玩家分为狼人阵营和好人阵营。</p>
                    <p>游戏分为白天和黑夜，在黑夜里各角色按顺序行动使用技能，白天所有玩家讨论并投票放逐一名玩家。</p>
                    <p>好人阵营获胜条件：清除所有狼人</p>
                    <p>狼人阵营获胜条件：狼人数量大于等于好人数量</p>
                    
                    <h3 class="text-lg font-medium mt-4">角色介绍</h3>
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                        <div>
                            <h4 class="font-medium text-wolf">狼人阵营</h4>
                            <ul class="list-disc pl-5">
                                <li>狼人：每晚可以杀死一名玩家</li>
                                <li>狼王：被放逐时可以带走一名玩家</li>
                                <li>隐狼：对预言家的查验显示为好人</li>
                            </ul>
                        </div>
                        <div>
                            <h4 class="font-medium text-villager">好人阵营</h4>
                            <ul class="list-disc pl-5">
                                <li>平民：没有特殊技能，靠推理保护自己</li>
                                <li>女巫：拥有一瓶解药和一瓶毒药</li>
                                <li>猎人：被放逐或死亡时可以带走一名玩家</li>
                                <li>守卫：每晚可以保护一名玩家</li>
                                <li>预言家：每晚可以查验一名玩家的身份</li>
                                <li>白痴：被投票出局后仍然可以发言，但失去投票权</li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- 房间设置屏幕 -->
        <div id="room-setup-screen" class="hidden fade-in">
            <div class="flex justify-between items-center mb-6">
                <h1 class="text-2xl font-bold">房间设置</h1>
                <div class="flex items-center">
                    <div class="mr-4">
                        <span class="font-medium">房间代码：</span>
                        <span id="display-room-code" class="font-mono bg-gray-100 dark:bg-gray-700 px-2 py-1 rounded">XXXX</span>
                        <button id="copy-code-btn" class="text-primary hover:text-indigo-700 ml-1">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                                <path d="M8 3a1 1 0 011-1h2a1 1 0 110 2H9a1 1 0 01-1-1z" />
                                <path d="M6 3a2 2 0 00-2 2v11a2 2 0 002 2h8a2 2 0 002-2V5a2 2 0 00-2-2 3 3 0 01-3 3H9a3 3 0 01-3-3z" />
                            </svg>
                        </button>
                    </div>
                    <button id="back-to-welcome-btn" class="text-gray-600 hover:text-gray-800 dark:text-gray-400 dark:hover:text-gray-200">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />
                        </svg>
                    </button>
                </div>
            </div>
            
            <div class="bg-white dark:bg-gray-800 rounded-lg shadow-lg p-6 mb-6">
                <h2 class="text-xl font-semibold mb-4">游戏设置</h2>
                <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                    <div>
                        <label for="player-count" class="block mb-2 text-sm font-medium">玩家人数</label>
                        <select id="player-count" class="w-full px-3 py-2 text-base border rounded-md focus:outline-none focus:ring-2 focus:ring-primary dark:bg-gray-700 dark:border-gray-600">
                            <option value="6">6人</option>
                            <option value="7">7人</option>
                            <option value="8">8人</option>
                            <option value="9">9人</option>
                            <option value="10">10人</option>
                            <option value="11">11人</option>
                            <option value="12">12人</option>
                        </select>
                    </div>
                    <div>
                        <label class="block mb-2 text-sm font-medium">推荐配置</label>
                        <button id="recommended-setup-btn" class="bg-primary hover:bg-indigo-600 text-white font-medium py-2 px-4 rounded-md transition">使用推荐配置</button>
                    </div>
                </div>
                
                <div class="mt-6">
                    <h3 class="font-medium mb-3">角色配置</h3>
                    <div class="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 gap-3">
                        <div class="flex items-center">
                            <input type="number" id="role-wolf" min="0" max="5" value="2" class="w-12 text-center px-2 py-1 text-base border rounded-md focus:outline-none focus:ring-2 focus:ring-primary dark:bg-gray-700 dark:border-gray-600">
                            <label for="role-wolf" class="ml-2">狼人</label>
                        </div>
                        <div class="flex items-center">
                            <input type="number" id="role-wolf-king" min="0" max="1" value="0" class="w-12 text-center px-2 py-1 text-base border rounded-md focus:outline-none focus:ring-2 focus:ring-primary dark:bg-gray-700 dark:border-gray-600">
                            <label for="role-wolf-king" class="ml-2">狼王</label>
                        </div>
                        <div class="flex items-center">
                            <input type="number" id="role-secret-wolf" min="0" max="1" value="0" class="w-12 text-center px-2 py-1 text-base border rounded-md focus:outline-none focus:ring-2 focus:ring-primary dark:bg-gray-700 dark:border-gray-600">
                            <label for="role-secret-wolf" class="ml-2">隐狼</label>
                        </div>
                        <div class="flex items-center">
                            <input type="number" id="role-villager" min="0" max="10" value="1" class="w-12 text-center px-2 py-1 text-base border rounded-md focus:outline-none focus:ring-2 focus:ring-primary dark:bg-gray-700 dark:border-gray-600">
                            <label for="role-villager" class="ml-2">平民</label>
                        </div>
                        <div class="flex items-center">
                            <input type="number" id="role-witch" min="0" max="1" value="1" class="w-12 text-center px-2 py-1 text-base border rounded-md focus:outline-none focus:ring-2 focus:ring-primary dark:bg-gray-700 dark:border-gray-600">
                            <label for="role-witch" class="ml-2">女巫</label>
                        </div>
                        <div class="flex items-center">
                            <input type="number" id="role-hunter" min="0" max="1" value="1" class="w-12 text-center px-2 py-1 text-base border rounded-md focus:outline-none focus:ring-2 focus:ring-primary dark:bg-gray-700 dark:border-gray-600">
                            <label for="role-hunter" class="ml-2">猎人</label>
                        </div>
                        <div class="flex items-center">
                            <input type="number" id="role-guard" min="0" max="1" value="0" class="w-12 text-center px-2 py-1 text-base border rounded-md focus:outline-none focus:ring-2 focus:ring-primary dark:bg-gray-700 dark:border-gray-600">
                            <label for="role-guard" class="ml-2">守卫</label>
                        </div>
                        <div class="flex items-center">
                            <input type="number" id="role-seer" min="0" max="1" value="1" class="w-12 text-center px-2 py-1 text-base border rounded-md focus:outline-none focus:ring-2 focus:ring-primary dark:bg-gray-700 dark:border-gray-600">
                            <label for="role-seer" class="ml-2">预言家</label>
                        </div>
                        <div class="flex items-center">
                            <input type="number" id="role-idiot" min="0" max="1" value="0" class="w-12 text-center px-2 py-1 text-base border rounded-md focus:outline-none focus:ring-2 focus:ring-primary dark:bg-gray-700 dark:border-gray-600">
                            <label for="role-idiot" class="ml-2">白痴</label>
                        </div>
                    </div>
                    <div class="mt-3 text-sm text-gray-600 dark:text-gray-400" id="role-count-warning">
                        当前配置：总人数 <span id="total-roles">6</span> / 需要 <span id="required-players">6</span> 人
                    </div>
                </div>
            </div>
            
            <div class="bg-white dark:bg-gray-800 rounded-lg shadow-lg p-6 mb-6">
                <h2 class="text-xl font-semibold mb-4">玩家列表</h2>
                <ul id="player-list" class="divide-y divide-gray-200 dark:divide-gray-700">
                    <li class="py-3 flex justify-between items-center">
                        <div class="flex items-center">
                            <span class="inline-block h-8 w-8 rounded-full bg-primary text-white flex items-center justify-center mr-3">
                                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                                    <path fill-rule="evenodd" d="M10 9a3 3 0 100-6 3 3 0 000 6zm-7 9a7 7 0 1114 0H3z" clip-rule="evenodd" />
                                </svg>
                            </span>
                            <span class="font-medium">房主 (你)</span>
                        </div>
                        <span class="text-sm text-gray-600 dark:text-gray-400">准备中</span>
                    </li>
                    <!-- 其他玩家将在这里显示 -->
                </ul>
                <div class="mt-6 flex flex-col sm:flex-row gap-3">
                    <button id="start-game-btn" class="flex-1 bg-primary hover:bg-indigo-600 text-white font-medium py-2 px-4 rounded-md transition">开始游戏</button>
                    <button id="add-ai-btn" class="flex-1 bg-green-600 hover:bg-green-700 text-white font-medium py-2 px-4 rounded-md transition">添加AI玩家</button>
                </div>
            </div>
        </div>
        
        <!-- 等待游戏开始屏幕 -->
        <div id="waiting-screen" class="hidden fade-in">
            <div class="flex justify-between items-center mb-6">
                <h1 class="text-2xl font-bold">等待游戏开始</h1>
                <button id="leave-room-btn" class="text-gray-600 hover:text-gray-800 dark:text-gray-400 dark:hover:text-gray-200">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />
                    </svg>
                </button>
            </div>
            
            <div class="bg-white dark:bg-gray-800 rounded-lg shadow-lg p-6 mb-6">
                <h2 class="text-xl font-semibold mb-4">房间信息</h2>
                <div class="mb-4">
                    <span class="font-medium">房间代码：</span>
                    <span id="waiting-room-code" class="font-mono bg-gray-100 dark:bg-gray-700 px-2 py-1 rounded">XXXX</span>
                </div>
                <div class="mb-4">
                    <span class="font-medium">房主：</span>
                    <span id="waiting-host-name">...</span>
                </div>
                <div>
                    <h3 class="font-medium mb-2">玩家列表</h3>
                    <ul id="waiting-player-list" class="divide-y divide-gray-200 dark:divide-gray-700">
                        <!-- 玩家将在这里显示 -->
                    </ul>
                </div>
            </div>
        </div>
        
        <!-- 游戏屏幕 -->
        <div id="game-screen" class="hidden fade-in">
            <div class="relative" id="game-container">
                <!-- 夜晚滤镜 -->
                <div id="night-overlay" class="hidden fixed inset-0 z-10 night-filter flex items-center justify-center">
                    <div class="text-center text-white">
                        <div class="text-6xl mb-4">🌙</div>
                        <h2 class="text-2xl font-bold mb-2">夜晚降临</h2>
                        <p class="text-lg" id="night-message">安静入睡，等待你的回合...</p>
                    </div>
                </div>
                
                <!-- 游戏头部信息 -->
                <div class="flex justify-between items-center mb-4">
                    <div>
                        <h1 class="text-2xl font-bold">狼人杀 <span id="game-phase-indicator" class="ml-2 text-sm font-normal px-2 py-0.5 rounded-full bg-blue-100 text-blue-800 dark:bg-blue-900 dark:text-blue-200">准备阶段</span></h1>
                    </div>
                    <div class="flex items-center">
                        <button id="game-menu-btn" class="text-gray-600 hover:text-gray-800 dark:text-gray-400 dark:hover:text-gray-200 mr-2">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h16" />
                            </svg>
                        </button>
                    </div>
                </div>
                
                <!-- 角色信息 -->
                <div class="grid grid-cols-1 lg:grid-cols-12 gap-4 mb-4">
                    <div class="lg:col-span-3">
                        <div class="bg-white dark:bg-gray-800 rounded-lg shadow-lg p-4">
                            <h2 class="text-lg font-semibold mb-3">你的角色</h2>
                            <div class="flex justify-center">
                                <div class="role-card" id="player-role-card">
                                    <div class="role-card-inner">
                                        <div class="role-card-front bg-gray-200 dark:bg-gray-700 flex items-center justify-center">
                                            <div class="text-4xl">❓</div>
                                        </div>
                                        <div class="role-card-back bg-primary flex flex-col items-center justify-center text-white p-2">
                                            <div id="role-icon" class="text-3xl mb-2">🐺</div>
                                            <div id="role-name" class="font-bold text-center">未知角色</div>
                                            <div id="role-team" class="text-xs mt-1">阵营：未知</div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                            <button id="view-role-btn" class="w-full mt-4 bg-primary hover:bg-indigo-600 text-white font-medium py-2 px-4 rounded-md transition">查看角色</button>
                            <div id="role-description" class="mt-4 text-sm hidden">
                                <p class="font-medium mb-1">角色说明：</p>
                                <p>-</p>
                                <div id="role-ability" class="mt-2">
                                    <!-- 角色能力按钮将在这里显示 -->
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <div class="lg:col-span-9">
                        <div class="bg-white dark:bg-gray-800 rounded-lg shadow-lg p-4">
                            <h2 class="text-lg font-semibold mb-3">玩家状态</h2>
                            <div class="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-5 gap-3" id="player-status-grid">
                                <!-- 玩家状态将在这里显示 -->
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- 游戏日志和聊天 -->
                <div class="grid grid-cols-1 lg:grid-cols-2 gap-4">
                    <div class="bg-white dark:bg-gray-800 rounded-lg shadow-lg p-4">
                        <h2 class="text-lg font-semibold mb-3">游戏日志</h2>
                        <div id="game-log" class="h-64 overflow-y-auto p-3 bg-gray-50 dark:bg-gray-900 rounded border border-gray-200 dark:border-gray-700 mb-3 text-sm">
                            <p class="text-gray-600 dark:text-gray-400">游戏即将开始...</p>
                        </div>
                    </div>
                    
                    <div class="bg-white dark:bg-gray-800 rounded-lg shadow-lg p-4">
                        <h2 class="text-lg font-semibold mb-3">聊天面板 <span id="chat-status" class="ml-2 text-xs font-normal px-2 py-0.5 rounded-full bg-red-100 text-red-800 dark:bg-red-900 dark:text-red-200">夜晚禁言</span></h2>
                        <div id="chat-messages" class="h-64 overflow-y-auto p-3 bg-gray-50 dark:bg-gray-900 rounded border border-gray-200 dark:border-gray-700 mb-3 text-sm">
                            <p class="text-gray-600 dark:text-gray-400">白天到来时才能发言...</p>
                        </div>
                        <div class="flex">
                            <input type="text" id="chat-input" class="flex-1 px-3 py-2 text-base border rounded-l-md focus:outline-none focus:ring-2 focus:ring-primary dark:bg-gray-700 dark:border-gray-600" placeholder="输入聊天内容..." disabled>
                            <button id="send-chat-btn" class="bg-primary hover:bg-indigo-600 text-white font-medium py-2 px-4 rounded-r-md transition disabled:bg-gray-400 disabled:cursor-not-allowed" disabled>发送</button>
                        </div>
                    </div>
                </div>
                
                <!-- 发言轮次指示器 -->
                <div id="speaking-turn-indicator" class="mt-4 bg-white dark:bg-gray-800 rounded-lg shadow-lg p-4 hidden">
                    <h2 class="text-lg font-semibold mb-3">发言环节</h2>
                    <p class="mb-3" id="speaking-instruction">当前玩家发言中，请等待轮到你发言...</p>
                    <div class="flex flex-wrap gap-3 mb-4" id="speaking-order">
                        <!-- 发言顺序将在这里显示 -->
                    </div>
                    <div class="mt-2">
                        <button id="next-speaker-btn" class="bg-primary hover:bg-indigo-600 text-white font-medium py-2 px-4 rounded-md transition hidden">下一位发言</button>
                        <div id="speaking-timer" class="text-sm text-gray-600 dark:text-gray-400 mt-1">剩余时间: <span id="speaking-time-left">60</span>秒</div>
                    </div>
                </div>
                
                <!-- 投票区域 -->
                <div id="vote-area" class="mt-4 bg-white dark:bg-gray-800 rounded-lg shadow-lg p-4 hidden">
                    <h2 class="text-lg font-semibold mb-3">投票环节</h2>
                    <p class="mb-3" id="vote-instruction">请选择一名玩家进行投票放逐：</p>
                    <div class="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-6 gap-3" id="vote-options">
                        <!-- 投票选项将在这里显示 -->
                    </div>
                    <div class="mt-4">
                        <button id="confirm-vote-btn" class="bg-primary hover:bg-indigo-600 text-white font-medium py-2 px-4 rounded-md transition">确认投票</button>
                        <button id="skip-vote-btn" class="ml-2 bg-gray-200 dark:bg-gray-700 hover:bg-gray-300 dark:hover:bg-gray-600 text-gray-800 dark:text-gray-200 font-medium py-2 px-4 rounded-md transition">弃权</button>
                    </div>
                </div>
                
                <!-- 特殊能力区域 -->
                <div id="ability-area" class="mt-4 bg-white dark:bg-gray-800 rounded-lg shadow-lg p-4 hidden">
                    <h2 class="text-lg font-semibold mb-3" id="ability-title">使用能力</h2>
                    <p class="mb-3" id="ability-instruction">请选择一名玩家：</p>
                    <div class="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-6 gap-3" id="ability-options">
                        <!-- 能力选项将在这里显示 -->
                    </div>
                    <div class="mt-4">
                        <button id="confirm-ability-btn" class="bg-primary hover:bg-indigo-600 text-white font-medium py-2 px-4 rounded-md transition">确认</button>
                        <button id="skip-ability-btn" class="ml-2 bg-gray-200 dark:bg-gray-700 hover:bg-gray-300 dark:hover:bg-gray-600 text-gray-800 dark:text-gray-200 font-medium py-2 px-4 rounded-md transition">跳过</button>
                    </div>
                </div>
                
                <!-- 结果弹窗 -->
                <div id="result-modal" class="fixed inset-0 z-50 flex items-center justify-center p-4 hidden">
                    <div class="absolute inset-0 bg-black bg-opacity-50"></div>
                    <div class="relative bg-white dark:bg-gray-800 rounded-lg shadow-xl max-w-md w-full p-6">
                        <h2 class="text-2xl font-bold mb-4" id="result-title">游戏结束</h2>
                        <div id="result-content" class="mb-6">
                            <!-- 结果内容将在这里显示 -->
                        </div>
                        <div class="flex justify-end">
                            <button id="new-game-btn" class="bg-primary hover:bg-indigo-600 text-white font-medium py-2 px-4 rounded-md transition">返回主菜单</button>
                        </div>
                    </div>
                </div>
                
                <!-- 菜单弹窗 -->
                <div id="menu-modal" class="fixed inset-0 z-50 flex items-center justify-center p-4 hidden">
                    <div class="absolute inset-0 bg-black bg-opacity-50"></div>
                    <div class="relative bg-white dark:bg-gray-800 rounded-lg shadow-xl max-w-md w-full p-6">
                        <h2 class="text-2xl font-bold mb-4">游戏菜单</h2>
                        <div class="space-y-3">
                            <button id="resume-game-btn" class="w-full bg-primary hover:bg-indigo-600 text-white font-medium py-2 px-4 rounded-md transition">继续游戏</button>
                            <button id="rules-btn" class="w-full bg-gray-200 dark:bg-gray-700 hover:bg-gray-300 dark:hover:bg-gray-600 text-gray-800 dark:text-gray-200 font-medium py-2 px-4 rounded-md transition">查看规则</button>
                            <button id="quit-game-btn" class="w-full bg-red-500 hover:bg-red-600 text-white font-medium py-2 px-4 rounded-md transition">退出游戏</button>
                        </div>
                    </div>
                </div>
                
                <!-- 添加AI玩家弹窗 -->
                <div id="add-ai-modal" class="fixed inset-0 z-50 flex items-center justify-center p-4 hidden">
                    <div class="absolute inset-0 bg-black bg-opacity-50"></div>
                    <div class="relative bg-white dark:bg-gray-800 rounded-lg shadow-xl max-w-md w-full p-6">
                        <h2 class="text-2xl font-bold mb-4">添加AI玩家</h2>
                        <div class="mb-4">
                            <label for="ai-player-name" class="block mb-2 text-sm font-medium">AI玩家名字</label>
                            <input type="text" id="ai-player-name" class="w-full px-3 py-2 text-base border rounded-md focus:outline-none focus:ring-2 focus:ring-primary dark:bg-gray-700 dark:border-gray-600" placeholder="输入AI玩家名字">
                        </div>
                        <div class="mb-4">
                            <label for="ai-player-personality" class="block mb-2 text-sm font-medium">AI玩家性格</label>
                            <select id="ai-player-personality" class="w-full px-3 py-2 text-base border rounded-md focus:outline-none focus:ring-2 focus:ring-primary dark:bg-gray-700 dark:border-gray-600">
                                <option value="cautious">谨慎型 - 不轻易表态，善于隐藏身份</option>
                                <option value="aggressive">激进型 - 敢于质疑他人，发言直接</option>
                                <option value="logical">逻辑型 - 分析推理能力强，善于找出矛盾</option>
                                <option value="emotional">情绪型 - 容易情绪化，判断多基于直觉</option>
                                <option value="talkative">话多型 - 喜欢分享信息，但容易暴露</option>
                                <option value="random">随机性格</option>
                            </select>
                        </div>
                        <div class="flex justify-end space-x-3">
                            <button id="cancel-add-ai-btn" class="bg-gray-200 dark:bg-gray-700 hover:bg-gray-300 dark:hover:bg-gray-600 text-gray-800 dark:text-gray-200 font-medium py-2 px-4 rounded-md transition">取消</button>
                            <button id="confirm-add-ai-btn" class="bg-green-600 hover:bg-green-700 text-white font-medium py-2 px-4 rounded-md transition">添加</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // 暗黑模式支持
        if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
            document.documentElement.classList.add('dark');
        }
        window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', event => {
            if (event.matches) {
                document.documentElement.classList.add('dark');
            } else {
                document.documentElement.classList.remove('dark');
            }
        });

        // 游戏常量和配置
        const ROLE_ICONS = {
            'wolf': '🐺',
            'wolf-king': '👑',
            'secret-wolf': '🦊',
            'villager': '👨‍🌾',
            'witch': '🧙‍♀️',
            'hunter': '🔫',
            'guard': '🛡️',
            'seer': '👁️',
            'idiot': '🃏'
        };

        const ROLE_NAMES = {
            'wolf': '狼人',
            'wolf-king': '狼王',
            'secret-wolf': '隐狼',
            'villager': '平民',
            'witch': '女巫',
            'hunter': '猎人',
            'guard': '守卫',
            'seer': '预言家',
            'idiot': '白痴'
        };

        const ROLE_TEAMS = {
            'wolf': '狼人阵营',
            'wolf-king': '狼人阵营',
            'secret-wolf': '狼人阵营',
            'villager': '好人阵营',
            'witch': '好人阵营',
            'hunter': '好人阵营',
            'guard': '好人阵营',
            'seer': '好人阵营',
            'idiot': '好人阵营'
        };

        const ROLE_DESCRIPTIONS = {
            'wolf': '你是狼人，每晚可以和其他狼人一起杀死一名玩家。',
            'wolf-king': '你是狼王，拥有狼人的能力，并且被放逐时可以带走一名玩家。',
            'secret-wolf': '你是隐狼，对预言家的查验显示为好人，但你属于狼人阵营。',
            'villager': '你是平民，没有特殊技能，请通过推理找出狼人。',
            'witch': '你是女巫，拥有一瓶解药和一瓶毒药，每种药只能使用一次。',
            'hunter': '你是猎人，被放逐或被杀死时可以开枪带走一名玩家。',
            'guard': '你是守卫，每晚可以保护一名玩家免受狼人的伤害，但不能连续两晚保护同一个人。',
            'seer': '你是预言家，每晚可以查验一名玩家是好人还是狼人（隐狼除外）。',
            'idiot': '你是白痴，被投票出局后保留发言权，但失去投票权。'
        };

        const RECOMMENDED_SETUPS = {
            6: { 'wolf': 2, 'wolf-king': 0, 'secret-wolf': 0, 'villager': 1, 'witch': 1, 'hunter': 1, 'guard': 0, 'seer': 1, 'idiot': 0 },
            7: { 'wolf': 2, 'wolf-king': 0, 'secret-wolf': 0, 'villager': 2, 'witch': 1, 'hunter': 1, 'guard': 0, 'seer': 1, 'idiot': 0 },
            8: { 'wolf': 2, 'wolf-king': 1, 'secret-wolf': 0, 'villager': 2, 'witch': 1, 'hunter': 1, 'guard': 0, 'seer': 1, 'idiot': 0 },
            9: { 'wolf': 3, 'wolf-king': 0, 'secret-wolf': 0, 'villager': 3, 'witch': 1, 'hunter': 1, 'guard': 0, 'seer': 1, 'idiot': 0 },
            10: { 'wolf': 3, 'wolf-king': 0, 'secret-wolf': 1, 'villager': 3, 'witch': 1, 'hunter': 1, 'guard': 0, 'seer': 1, 'idiot': 0 },
            11: { 'wolf': 3, 'wolf-king': 1, 'secret-wolf': 0, 'villager': 3, 'witch': 1, 'hunter': 1, 'guard': 1, 'seer': 1, 'idiot': 0 },
            12: { 'wolf': 4, 'wolf-king': 0, 'secret-wolf': 0, 'villager': 4, 'witch': 1, 'hunter': 1, 'guard': 1, 'seer': 1, 'idiot': 0 }
        };

        // AI性格特征配置
        const AI_PERSONALITIES = {
            cautious: {
                roleRevealChance: 0.2,  // 直接暴露身份的几率
                falseClaim: 0.3,        // 虚假声明的几率（狼人冒充好人）
                accusationThreshold: 0.7, // 指控他人的阈值
                persuasivenessFactor: 0.6, // 说服力因子
                selfDefenseStrength: 0.8, // 自我辩护强度
                description: "谨慎型AI，不轻易表露立场，善于隐藏身份"
            },
            aggressive: {
                roleRevealChance: 0.4,
                falseClaim: 0.5,
                accusationThreshold: 0.4,
                persuasivenessFactor: 0.7,
                selfDefenseStrength: 0.6,
                description: "激进型AI，敢于质疑他人，发言直接"
            },
            logical: {
                roleRevealChance: 0.3,
                falseClaim: 0.2,
                accusationThreshold: 0.6,
                persuasivenessFactor: 0.8,
                selfDefenseStrength: 0.7,
                description: "逻辑型AI，分析推理能力强，善于找出矛盾"
            },
            emotional: {
                roleRevealChance: 0.5,
                falseClaim: 0.4,
                accusationThreshold: 0.3,
                persuasivenessFactor: 0.5,
                selfDefenseStrength: 0.5,
                description: "情绪型AI，容易情绪化，判断多基于直觉"
            },
            talkative: {
                roleRevealChance: 0.6,
                falseClaim: 0.3,
                accusationThreshold: 0.5,
                persuasivenessFactor: 0.6,
                selfDefenseStrength: 0.6,
                description: "话多型AI，喜欢分享信息，但容易暴露"
            }
        };

        // 生成发言模板库
        const SPEECH_TEMPLATES = {
            // 通用发言
            generic: {
                greeting: [
                    "大家好，我是{name}。",
                    "各位早上好，作为{name}，我想说几句。",
                    "好的，轮到我{name}发言了。"
                ],
                neutral: [
                    "我认为目前信息还不够多，需要大家多交流。",
                    "我们先听听每个人的发言，再做判断吧。",
                    "现在下结论还为时过早，多观察一下局势。",
                    "我觉得这一轮大家的发言都挺正常的。",
                    "我暂时没有特别怀疑的对象。"
                ],
                suspect: [
                    "我觉得{target}的发言有些奇怪，大家注意一下。",
                    "{target}刚才的表现有点可疑，可能需要解释一下。",
                    "我个人认为{target}的行为有些反常，不知道大家怎么看？",
                    "听了{target}的发言，我感觉有些地方不太自然。"
                ],
                defend: [
                    "我不是狼人，请大家相信我。",
                    "我是好人，不要被误导了。",
                    "我真的是好人阵营，投我出局对好人不利。",
                    "我明白看起来很可疑，但我确实不是狼人。"
                ],
                closing: [
                    "我的发言结束，谢谢大家。",
                    "以上是我的看法，下一位请。",
                    "就说这么多吧，希望对大家有帮助。",
                    "我说完了，请大家仔细思考。"
                ]
            },
            
            // 角色特定发言
            villager: {
                claim: [
                    "我是一名平民，没有特殊能力，只能靠推理。",
                    "我是平民，希望有特殊身份的好人能站出来带领我们。",
                    "作为平民，我只能通过观察大家的言行来找出狼人。"
                ],
                analysis: [
                    "从目前的情况看，我感觉{target}可能是狼人。",
                    "虽然我只是平民，但我觉得{target}的发言很矛盾。",
                    "作为一个平民，我的直觉告诉我{target}不太对劲。"
                ]
            },
            
            wolf: {
                fake_claim: [
                    "我其实是预言家，昨晚我查验了{target}，他是好人。",
                    "我是守卫，昨晚我保护了{target}。",
                    "作为一名平民，我只能尽力分析大家的发言。",
                    "我是女巫，昨晚我用了解药救了被狼人袭击的人。"
                ],
                accusation: [
                    "我觉得{target}很可能是狼人，他的发言前后矛盾。",
                    "大家注意一下{target}，他好像在刻意转移视线。",
                    "我认为{target}最可疑，他一直在误导大家。",
                    "{target}的行为很像是在伪装，建议大家投他。"
                ],
                defense: [
                    "我不是狼人，可能是预言家查错了。",
                    "预言家可能被狼人冒充了，我是好人。",
                    "不要被表面现象迷惑，真正的狼人是{target}。",
                    "大家冷静一下，投我出局对好人阵营不利。"
                ]
            },
            
            seer: {
                claim: [
                    "我是预言家，昨晚我查验了{target}，他是{result}。",
                    "作为预言家，我要告诉大家{target}是{result}。",
                    "我是预言家，我昨晚查到{target}是{result}，请大家相信我。"
                ],
                reasoning: [
                    "根据我的查验结果，我们应该先处理已知的狼人。",
                    "我建议大家相信我的查验，集中火力处理狼人。",
                    "作为预言家，我的信息对好人阵营至关重要。"
                ]
            },
            
            witch: {
                claim: [
                    "我是女巫，昨晚我{action}。",
                    "作为女巫，我想告诉大家昨晚我{action}。",
                    "我是女巫，我{action}，希望这个信息对大家有帮助。"
                ],
                strategy: [
                    "我的解药和毒药都还在，需要谨慎使用。",
                    "我已经用掉了解药，但毒药还在，请大家给我提供线索。",
                    "我的两瓶药都用完了，但希望我提供的信息能帮助大家。"
                ]
            },
            
            hunter: {
                claim: [
                    "我是猎人，如果我被投出去，我会开枪带走我认为的狼人。",
                    "作为猎人，我希望大家不要投我，我的能力对好人阵营很重要。",
                    "我是猎人，即使我死了也能带走一个人，狼人最好别惹我。"
                ],
                threat: [
                    "如果我被投出，我会开枪打死{target}，我怀疑他是狼人。",
                    "狼人们要小心，就算我死了也能带走你们中的一个。",
                    "我的能力是双刃剑，投我出局不一定对狼人有利。"
                ]
            },
            
            guard: {
                claim: [
                    "我是守卫，昨晚我保护了{target}。",
                    "作为守卫，我昨晚守护了{target}，他应该平安无事。",
                    "我是守卫，我选择保护{target}，希望没有保护错人。"
                ],
                strategy: [
                    "我会尽量保护关键角色，请预言家或女巫私下告诉我你们是谁。",
                    "我不能连续两晚保护同一个人，所以需要合理安排。",
                    "守卫的作用是阻止狼人击杀，我会尽力保护好人阵营。"
                ]
            },
            
            idiot: {
                claim: [
                    "我是白痴，即使被投出局也能继续发言。",
                    "作为白痴，我被投出后还能说话，但没有投票权。",
                    "我是白痴，投我出局不会让我闭嘴，但会浪费一次机会。"
                ],
                argument: [
                    "即使我已经出局，我也要说{target}很可疑。",
                    "虽然我没有投票权了，但我的判断是{target}最像狼人。",
                    "作为一个已出局的白痴，我观察到{target}行为反常。"
                ]
            }
        };

        // 全局游戏状态
        const gameState = {
            isHost: false,
            roomCode: null,
            peer: null,
            connections: {},
            players: [],
            aiPlayers: [],
            playerName: '',
            playerRole: null,
            roleSettings: {},
            gamePhase: 'waiting',
            day: 0,
            currentTurn: null,
            speakingQueue: [],
            currentSpeaker: null,
            speakingTimeLeft: 60,
            speakingTimer: null,
            votes: {},
            wolfVotes: {},
            witchSaveTarget: null,
            witchPoisonTarget: null,
            witchSaveUsed: false,
            witchPoisonUsed: false,
            guardTarget: null,
            lastGuardTarget: null,
            seerTarget: null,
            killedAtNight: null,
            savedByWitch: false,
            poisonedByWitch: null,
            huntedByHunter: null,
            hunterDead: false,
            wolfKingDead: false,
            selectedAbilityTarget: null,
            deadPlayers: [],
            winningTeam: null,
            gameStarted: false,
            gameEnded: false,
            villagerCount: 0,
            wolfCount: 0,
            spectators: [],
            inited: false
        };

        // 通用工具函数
        function generateRoomCode() {
            return Math.random().toString(36).substring(2, 6).toUpperCase();
        }

        function showScreen(screenId) {
            document.querySelectorAll('#app > div').forEach(div => {
                div.classList.add('hidden');
            });
            document.getElementById(screenId).classList.remove('hidden');
        }

        function showModal(modalId) {
            document.getElementById(modalId).classList.remove('hidden');
        }

        function hideModal(modalId) {
            document.getElementById(modalId).classList.add('hidden');
        }

        function updatePlayerList() {
            const list = document.getElementById('player-list');
            list.innerHTML = '';

            gameState.players.forEach((player, index) => {
                const li = document.createElement('li');
                li.className = 'py-3 flex justify-between items-center';
                
                const isAI = player.isAI;
                const isYou = player.id === gameState.peer.id;
                const isHost = player.id === gameState.players[0]?.id;
                
                let nameDisplay = player.name;
                if (isYou) nameDisplay += ' (你)';
                if (isHost) nameDisplay = '房主 ' + nameDisplay;
                if (isAI) nameDisplay += ' [AI]';
                
                li.innerHTML = `
                    <div class="flex items-center">
                        <span class="inline-block h-8 w-8 rounded-full ${isAI ? 'bg-green-500' : 'bg-primary'} text-white flex items-center justify-center mr-3">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                                <path fill-rule="evenodd" d="M10 9a3 3 0 100-6 3 3 0 000 6zm-7 9a7 7 0 1114 0H3z" clip-rule="evenodd" />
                            </svg>
                        </span>
                        <span class="font-medium">${nameDisplay}</span>
                    </div>
                    <span class="text-sm text-gray-600 dark:text-gray-400">准备中</span>
                `;
                list.appendChild(li);
                
                // 如果是房主且不是自己，添加移除按钮
                if (gameState.isHost && !isYou && !gameState.gameStarted) {
                    const removeBtn = document.createElement('button');
                    removeBtn.className = 'ml-2 text-red-500 hover:text-red-700';
                    removeBtn.innerHTML = `
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                            <path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd" />
                        </svg>
                    `;
                    
                    removeBtn.addEventListener('click', () => {
                        if (player.isAI) {
                            // 移除AI玩家
                            gameState.players = gameState.players.filter(p => p.id !== player.id);
                            updatePlayerList();
                            // 广播玩家列表更新
                            broadcastGameState();
                        } else {
                            // 提示是否移除真实玩家
                            if (confirm(`确定要将 ${player.name} 移出房间吗？`)) {
                                // 发送移除消息给该玩家
                                gameState.connections[player.id].send({
                                    type: 'kick',
                                    message: '你已被房主移出房间'
                                });
                                // 从玩家列表中移除
                                gameState.players = gameState.players.filter(p => p.id !== player.id);
                                updatePlayerList();
                                // 广播玩家列表更新
                                broadcastGameState();
                            }
                        }
                    });
                    
                    li.querySelector('div:last-child').prepend(removeBtn);
                }
            });
            
            // 更新等待页面的玩家列表
            const waitingList = document.getElementById('waiting-player-list');
            if (waitingList) {
                waitingList.innerHTML = '';
                gameState.players.forEach(player => {
                    const li = document.createElement('li');
                    li.className = 'py-3 flex items-center';
                    
                    const isAI = player.isAI;
                    const isYou = player.id === gameState.peer.id;
                    const isHost = player.id === gameState.players[0]?.id;
                    
                    let nameDisplay = player.name;
                    if (isYou) nameDisplay += ' (你)';
                    if (isHost) nameDisplay = '房主 ' + nameDisplay;
                    if (isAI) nameDisplay += ' [AI]';
                    
                    li.innerHTML = `
                        <span class="inline-block h-8 w-8 rounded-full ${isAI ? 'bg-green-500' : 'bg-primary'} text-white flex items-center justify-center mr-3">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                                <path fill-rule="evenodd" d="M10 9a3 3 0 100-6 3 3 0 000 6zm-7 9a7 7 0 1114 0H3z" clip-rule="evenodd" />
                            </svg>
                        </span>
                        <span class="font-medium">${nameDisplay}</span>
                    `;
                    waitingList.appendChild(li);
                });
            }
        }

        function updateRoleCountWarning() {
            const totalRoles = calculateTotalRoles();
            const requiredPlayers = document.getElementById('player-count').value;
            
            document.getElementById('total-roles').textContent = totalRoles;
            document.getElementById('required-players').textContent = requiredPlayers;
            
            const warningElement = document.getElementById('role-count-warning');
            
            if (totalRoles != requiredPlayers) {
                warningElement.classList.add('text-red-600', 'dark:text-red-400');
                warningElement.classList.remove('text-gray-600', 'dark:text-gray-400');
            } else {
                warningElement.classList.remove('text-red-600', 'dark:text-red-400');
                warningElement.classList.add('text-gray-600', 'dark:text-gray-400');
            }
        }

        function calculateTotalRoles() {
            let total = 0;
            const roleIds = ['wolf', 'wolf-king', 'secret-wolf', 'villager', 'witch', 'hunter', 'guard', 'seer', 'idiot'];
            
            roleIds.forEach(roleId => {
                const element = document.getElementById(`role-${roleId}`);
                total += parseInt(element.value);
            });
            
            return total;
        }

        function updateRoleSettings() {
            const roleIds = ['wolf', 'wolf-king', 'secret-wolf', 'villager', 'witch', 'hunter', 'guard', 'seer', 'idiot'];
            
            roleIds.forEach(roleId => {
                const element = document.getElementById(`role-${roleId}`);
                gameState.roleSettings[roleId] = parseInt(element.value);
            });
        }

        function applyRecommendedSetup() {
            const playerCount = document.getElementById('player-count').value;
            const setup = RECOMMENDED_SETUPS[playerCount];
            
            if (setup) {
                for (const [roleId, count] of Object.entries(setup)) {
                    document.getElementById(`role-${roleId}`).value = count;
                }
                updateRoleCountWarning();
            }
        }

        function getRandomWolfStatement(aiPlayer, players, deadPlayers) {
            const personality = AI_PERSONALITIES[aiPlayer.personality];
            const templates = SPEECH_TEMPLATES.wolf;
            const generic = SPEECH_TEMPLATES.generic;
            
            // 决定是否冒充好人身份
            const willFakeClaim = Math.random() < personality.falseClaim;
            
            // 随机选择活着的非狼队友作为目标
            const alivePlayers = players.filter(p => !deadPlayers.includes(p.id) && 
                                             !['wolf', 'wolf-king', 'secret-wolf'].includes(p.role));
            
            const targetPlayer = alivePlayers[Math.floor(Math.random() * alivePlayers.length)];
            let statement = "";
            
            // 添加问候
            statement += generic.greeting[Math.floor(Math.random() * generic.greeting.length)].replace('{name}', aiPlayer.name);
            statement += " ";
            
            // 如果决定冒充好人身份
            if (willFakeClaim) {
                // 随机选择一个冒充身份的话术
                const fakeClaim = templates.fake_claim[Math.floor(Math.random() * templates.fake_claim.length)]
                    .replace('{target}', targetPlayer ? targetPlayer.name : '某个玩家');
                statement += fakeClaim;
                statement += " ";
            } else {
                // 使用中性发言
                statement += generic.neutral[Math.floor(Math.random() * generic.neutral.length)];
                statement += " ";
            }
            
            // 添加对某人的指控，转移视线
            if (targetPlayer && Math.random() < personality.accusationThreshold) {
                const accusation = templates.accusation[Math.floor(Math.random() * templates.accusation.length)]
                    .replace('{target}', targetPlayer.name);
                statement += accusation;
                statement += " ";
            }
            
            // 如果被怀疑，添加防御发言
            if (aiPlayer.isAccused && Math.random() < personality.selfDefenseStrength) {
                const defense = templates.defense[Math.floor(Math.random() * templates.defense.length)]
                    .replace('{target}', targetPlayer ? targetPlayer.name : '某个玩家');
                statement += defense;
                statement += " ";
            }
            
            // 添加结束语
            statement += generic.closing[Math.floor(Math.random() * generic.closing.length)];
            
            return statement;
        }

        function getRandomVillagerStatement(aiPlayer, players, deadPlayers, role = 'villager') {
            const personality = AI_PERSONALITIES[aiPlayer.personality];
            const templates = SPEECH_TEMPLATES[role] || SPEECH_TEMPLATES.villager;
            const generic = SPEECH_TEMPLATES.generic;
            
            // 决定是否透露身份
            const willReveal = Math.random() < personality.roleRevealChance;
            
            // 随机选择活着的玩家作为目标
            const alivePlayers = players.filter(p => !deadPlayers.includes(p.id) && p.id !== aiPlayer.id);
            const suspiciousPlayers = aiPlayer.suspicions || [];
            
            // 优先选择怀疑名单中的玩家
            let targetPlayer = null;
            if (suspiciousPlayers.length > 0 && Math.random() < 0.7) {
                const suspiciousId = suspiciousPlayers[Math.floor(Math.random() * suspiciousPlayers.length)];
                targetPlayer = players.find(p => p.id === suspiciousId);
            }
            
            // 如果没有可疑玩家或随机选择了其他人
            if (!targetPlayer && alivePlayers.length > 0) {
                targetPlayer = alivePlayers[Math.floor(Math.random() * alivePlayers.length)];
            }
            
            let statement = "";
            
            // 添加问候
            statement += generic.greeting[Math.floor(Math.random() * generic.greeting.length)].replace('{name}', aiPlayer.name);
            statement += " ";
            
            // 如果决定透露身份
            if (willReveal) {
                switch(role) {
                    case 'villager':
                        statement += templates.claim[Math.floor(Math.random() * templates.claim.length)];
                        break;
                    case 'seer':
                        if (aiPlayer.seerResults && aiPlayer.seerResults.length > 0) {
                            const lastResult = aiPlayer.seerResults[aiPlayer.seerResults.length - 1];
                            statement += templates.claim[Math.floor(Math.random() * templates.claim.length)]
                                .replace('{target}', lastResult.playerName)
                                .replace('{result}', lastResult.isWolf ? '狼人' : '好人');
                        } else {
                            statement += templates.claim[0]
                                .replace('{target}', targetPlayer ? targetPlayer.name : '某人')
                                .replace('{result}', '好人'); // 默认声称查到好人
                        }
                        break;
                    case 'witch':
                        let action = '还没有使用任何药';
                        if (aiPlayer.witchSaveUsed) action = '用了解药';
                        if (aiPlayer.witchPoisonUsed) action = '用了毒药';
                        if (aiPlayer.witchSaveUsed && aiPlayer.witchPoisonUsed) action = '已经用完了两瓶药';
                        
                        statement += templates.claim[Math.floor(Math.random() * templates.claim.length)]
                            .replace('{action}', action);
                        break;
                    case 'hunter':
                    case 'guard':
                    case 'idiot':
                        statement += templates.claim[Math.floor(Math.random() * templates.claim.length)];
                        if (targetPlayer && role === 'guard') {
                            statement = statement.replace('{target}', targetPlayer.name);
                        }
                        break;
                }
                statement += " ";
            } else {
                // 使用中性发言
                statement += generic.neutral[Math.floor(Math.random() * generic.neutral.length)];
                statement += " ";
            }
            
            // 添加对某人的怀疑
            if (targetPlayer && Math.random() < personality.accusationThreshold) {
                let suspicion;
                if (role === 'villager') {
                    suspicion = templates.analysis[Math.floor(Math.random() * templates.analysis.length)];
                } else {
                    suspicion = generic.suspect[Math.floor(Math.random() * generic.suspect.length)];
                }
                statement += suspicion.replace('{target}', targetPlayer.name);
                statement += " ";
            }
            
            // 如果被怀疑，添加防御发言
            if (aiPlayer.isAccused && Math.random() < personality.selfDefenseStrength) {
                statement += generic.defend[Math.floor(Math.random() * generic.defend.length)];
                statement += " ";
            }
            
            // 添加特定角色的策略发言
            if (willReveal && role !== 'villager') {
                switch(role) {
                    case 'seer':
                        statement += templates.reasoning[Math.floor(Math.random() * templates.reasoning.length)];
                        statement += " ";
                        break;
                    case 'witch':
                        statement += templates.strategy[Math.floor(Math.random() * templates.strategy.length)];
                        statement += " ";
                        break;
                    case 'hunter':
                        if (targetPlayer) {
                            statement += templates.threat[Math.floor(Math.random() * templates.threat.length)]
                                .replace('{target}', targetPlayer.name);
                            statement += " ";
                        }
                        break;
                    case 'guard':
                        statement += templates.strategy[Math.floor(Math.random() * templates.strategy.length)];
                        statement += " ";
                        break;
                    case 'idiot':
                        if (targetPlayer && deadPlayers.includes(aiPlayer.id)) {
                            statement += templates.argument[Math.floor(Math.random() * templates.argument.length)]
                                .replace('{target}', targetPlayer.name);
                            statement += " ";
                        }
                        break;
                }
            }
            
            // 添加结束语
            statement += generic.closing[Math.floor(Math.random() * generic.closing.length)];
            
            return statement;
        }

        function getAIStatement(aiPlayer) {
            // 根据角色和性格生成语句
            if (['wolf', 'wolf-king', 'secret-wolf'].includes(aiPlayer.role)) {
                return getRandomWolfStatement(aiPlayer, gameState.players, gameState.deadPlayers);
            } else {
                return getRandomVillagerStatement(aiPlayer, gameState.players, gameState.deadPlayers, aiPlayer.role);
            }
        }

        function aiMakeDecision(aiPlayer, action) {
            // 让AI做出决策（投票、使用技能等）
            const alivePlayers = gameState.players.filter(p => !gameState.deadPlayers.includes(p.id) && p.id !== aiPlayer.id);
            
            switch(action) {
                case 'vote':
                    // AI投票逻辑
                    let voteTarget = null;
                    
                    // 狼人倾向于投好人
                    if (['wolf', 'wolf-king', 'secret-wolf'].includes(aiPlayer.role)) {
                        const goodPlayers = alivePlayers.filter(p => 
                            !['wolf', 'wolf-king', 'secret-wolf'].includes(p.role)
                        );
                        
                        if (goodPlayers.length > 0) {
                            voteTarget = goodPlayers[Math.floor(Math.random() * goodPlayers.length)].id;
                        }
                    } 
                    // 好人倾向于投可疑的人
                    else {
                        // 如果AI有怀疑列表，从中选择
                        if (aiPlayer.suspicions && aiPlayer.suspicions.length > 0) {
                            const suspiciousId = aiPlayer.suspicions[Math.floor(Math.random() * aiPlayer.suspicions.length)];
                            // 确保怀疑的玩家还活着
                            const suspiciousPlayer = alivePlayers.find(p => p.id === suspiciousId);
                            if (suspiciousPlayer) {
                                voteTarget = suspiciousPlayer.id;
                            }
                        }
                    }
                    
                    // 如果没有找到目标，随机选择一个
                    if (!voteTarget && alivePlayers.length > 0) {
                        voteTarget = alivePlayers[Math.floor(Math.random() * alivePlayers.length)].id;
                    }
                    
                    return voteTarget;
                
                case 'wolf_kill':
                    // 狼人杀人逻辑
                    if (['wolf', 'wolf-king', 'secret-wolf'].includes(aiPlayer.role)) {
                        const goodPlayers = alivePlayers.filter(p => 
                            !['wolf', 'wolf-king', 'secret-wolf'].includes(p.role)
                        );
                        
                        if (goodPlayers.length > 0) {
                            // 优先击杀特殊角色或明确的威胁
                            const specialRoles = goodPlayers.filter(p => 
                                ['seer', 'witch', 'hunter'].includes(p.role)
                            );
                            
                            if (specialRoles.length > 0) {
                                return specialRoles[Math.floor(Math.random() * specialRoles.length)].id;
                            } else {
                                return goodPlayers[Math.floor(Math.random() * goodPlayers.length)].id;
                            }
                        }
                    }
                    break;
                
                case 'witch_save':
                    // 女巫救人逻辑
                    if (aiPlayer.role === 'witch' && !aiPlayer.witchSaveUsed) {
                        // 60%的概率救人
                        return Math.random() < 0.6;
                    }
                    return false;
                
                case 'witch_poison':
                    // 女巫毒人逻辑
                    if (aiPlayer.role === 'witch' && !aiPlayer.witchPoisonUsed) {
                        // 狼人首选，然后是可疑玩家
                        const wolves = alivePlayers.filter(p => 
                            ['wolf', 'wolf-king', 'secret-wolf'].includes(p.role)
                        );
                        
                        if (wolves.length > 0 && Math.random() < 0.8) {
                            return wolves[Math.floor(Math.random() * wolves.length)].id;
                        } else if (aiPlayer.suspicions && aiPlayer.suspicions.length > 0) {
                            const suspiciousId = aiPlayer.suspicions[Math.floor(Math.random() * aiPlayer.suspicions.length)];
                            const suspiciousPlayer = alivePlayers.find(p => p.id === suspiciousId);
                            if (suspiciousPlayer) {
                                return suspiciousPlayer.id;
                            }
                        }
                    }
                    return null;
                
                case 'seer_check':
                    // 预言家查验逻辑
                    if (aiPlayer.role === 'seer') {
                        // 没有怀疑目标时随机查验
                        if (!aiPlayer.suspicions || aiPlayer.suspicions.length === 0) {
                            return alivePlayers[Math.floor(Math.random() * alivePlayers.length)].id;
                        } else {
                            // 从怀疑目标中查验
                            const suspiciousId = aiPlayer.suspicions[Math.floor(Math.random() * aiPlayer.suspicions.length)];
                            const suspiciousPlayer = alivePlayers.find(p => p.id === suspiciousId);
                            if (suspiciousPlayer) {
                                return suspiciousPlayer.id;
                            } else {
                                return alivePlayers[Math.floor(Math.random() * alivePlayers.length)].id;
                            }
                        }
                    }
                    break;
                
                case 'guard_protect':
                    // 守卫保护逻辑
                    if (aiPlayer.role === 'guard') {
                        // 找出活着的特殊好人角色
                        const specialGoodPlayers = alivePlayers.filter(p => 
                            ['seer', 'witch', 'hunter'].includes(p.role)
                        );
                        
                        let protectTarget = null;
                        
                        // 优先保护特殊好人
                        if (specialGoodPlayers.length > 0) {
                            protectTarget = specialGoodPlayers[Math.floor(Math.random() * specialGoodPlayers.length)].id;
                        } 
                        // 随机保护一个人
                        else if (alivePlayers.length > 0) {
                            protectTarget = alivePlayers[Math.floor(Math.random() * alivePlayers.length)].id;
                        }
                        
                        // 确保不连续两晚保护同一个人
                        if (protectTarget === aiPlayer.lastGuardTarget) {
                            const otherPlayers = alivePlayers.filter(p => p.id !== protectTarget);
                            if (otherPlayers.length > 0) {
                                protectTarget = otherPlayers[Math.floor(Math.random() * otherPlayers.length)].id;
                            }
                        }
                        
                        return protectTarget;
                    }
                    break;
                
                case 'hunter_shoot':
                case 'wolf_king_howl':
                    // 猎人开枪或狼王带人逻辑
                    if ((action === 'hunter_shoot' && aiPlayer.role === 'hunter') || 
                        (action === 'wolf_king_howl' && aiPlayer.role === 'wolf-king')) {
                        
                        if (action === 'hunter_shoot') {
                            // 猎人倾向于射杀狼人或可疑玩家
                            const wolves = alivePlayers.filter(p => 
                                ['wolf', 'wolf-king', 'secret-wolf'].includes(p.role)
                            );
                            
                            if (wolves.length > 0 && Math.random() < 0.8) {
                                return wolves[Math.floor(Math.random() * wolves.length)].id;
                            }
                        } else {
                            // 狼王倾向于带走好人或威胁
                            const goodPlayers = alivePlayers.filter(p => 
                                !['wolf', 'wolf-king', 'secret-wolf'].includes(p.role)
                            );
                            
                            if (goodPlayers.length > 0) {
                                // 优先带走特殊角色
                                const specialRoles = goodPlayers.filter(p => 
                                    ['seer', 'witch', 'hunter'].includes(p.role)
                                );
                                
                                if (specialRoles.length > 0) {
                                    return specialRoles[Math.floor(Math.random() * specialRoles.length)].id;
                                } else {
                                    return goodPlayers[Math.floor(Math.random() * goodPlayers.length)].id;
                                }
                            }
                        }
                        
                        // 如果没有特定目标，从可疑人物中选择
                        if (aiPlayer.suspicions && aiPlayer.suspicions.length > 0) {
                            const suspiciousId = aiPlayer.suspicions[Math.floor(Math.random() * aiPlayer.suspicions.length)];
                            const suspiciousPlayer = alivePlayers.find(p => p.id === suspiciousId);
                            if (suspiciousPlayer) {
                                return suspiciousPlayer.id;
                            }
                        }
                        
                        // 否则随机选择
                        if (alivePlayers.length > 0) {
                            return alivePlayers[Math.floor(Math.random() * alivePlayers.length)].id;
                        }
                    }
                    break;
            }
            
            return null;
        }

        // 初始化P2P连接
        function initPeer() {
            return new Promise((resolve, reject) => {
                const peer = new Peer({
                    config: {
                        'iceServers': [
                            { urls: 'stun:stun.l.google.com:19302' },
                            { urls: 'stun:stun1.l.google.com:19302' }
                        ]
                    }
                });
                
                peer.on('open', id => {
                    console.log('My peer ID is: ' + id);
                    gameState.peer = peer;
                    resolve(peer);
                });
                
                peer.on('error', err => {
                    console.error('Peer error:', err);
                    reject(err);
                });
                
                peer.on('connection', conn => {
                    handleNewConnection(conn);
                });
            });
        }

        function handleNewConnection(conn) {
            // 保存连接
            gameState.connections[conn.peer] = conn;
            
            conn.on('data', data => {
                handlePeerMessage(conn.peer, data);
            });
            
            conn.on('close', () => {
                // 处理玩家断开连接
                console.log('Connection closed with peer:', conn.peer);
                delete gameState.connections[conn.peer];
                
                // 如果游戏已经开始，将玩家标记为离线但不移除
                if (gameState.gameStarted) {
                    const playerIndex = gameState.players.findIndex(p => p.id === conn.peer);
                    if (playerIndex !== -1) {
                        gameState.players[playerIndex].isOffline = true;
                        addToGameLog(`${gameState.players[playerIndex].name} 已离线`);
                        
                        // 如果是房主离线且游戏已经开始，尝试将房主转移
                        if (playerIndex === 0) {
                            const newHostIndex = gameState.players.findIndex(p => !p.isOffline && !p.isAI);
                            if (newHostIndex !== -1) {
                                const newHost = gameState.players[newHostIndex];
                                const oldHost = gameState.players[0];
                                
                                // 交换位置
                                gameState.players[0] = newHost;
                                gameState.players[newHostIndex] = oldHost;
                                
                                addToGameLog(`房主已变更为 ${newHost.name}`);
                                
                                // 广播房主变更
                                broadcastGameState();
                            }
                        }
                    }
                } else {
                    // 游戏未开始，直接从玩家列表中移除
                    gameState.players = gameState.players.filter(p => p.id !== conn.peer);
                    updatePlayerList();
                    
                    // 广播玩家列表更新
                    broadcastGameState();
                }
            });
            
            conn.on('error', err => {
                console.error('Connection error:', err);
            });
        }

        function createRoom() {
            const playerName = document.getElementById('player-name-create').value.trim();
            
            if (!playerName) {
                alert('请输入你的名字');
                return;
            }
            
            gameState.playerName = playerName;
            gameState.roomCode = generateRoomCode();
            gameState.isHost = true;
            
            // 添加自己到玩家列表
            gameState.players.push({
                id: gameState.peer.id,
                name: playerName,
                isHost: true,
                isAI: false
            });
            
            // 显示房间代码
            document.getElementById('display-room-code').textContent = gameState.roomCode;
            document.getElementById('waiting-room-code').textContent = gameState.roomCode;
            document.getElementById('waiting-host-name').textContent = playerName;
            
            // 更新玩家列表并切换到房间设置屏幕
            updatePlayerList();
            showScreen('room-setup-screen');
        }

        async function joinRoom() {
            const playerName = document.getElementById('player-name-join').value.trim();
            const roomCode = document.getElementById('room-code').value.trim().toUpperCase();
            
            if (!playerName) {
                alert('请输入你的名字');
                return;
            }
            
            if (!roomCode) {
                alert('请输入房间代码');
                return;
            }
            
            gameState.playerName = playerName;
            gameState.roomCode = roomCode;
            gameState.isHost = false;
            
            try {
                // 显示等待界面
                showScreen('waiting-screen');
                document.getElementById('waiting-room-code').textContent = roomCode;
                
                // 向房主发送连接请求
                await window.Poe.sendUserMessage("@Claude-3.7-Sonnet 请等待其他真实玩家通过P2P连接到此房间。当玩家点击'加入房间'按钮时，系统将自动通过P2P网络建立连接。", {
                    stream: true,
                    openChat: false
                });
                
                // 在实际应用中，你需要一个信令服务器来匹配房间代码和Peer ID
                // 这里我们假设房间代码映射到某个函数调用，暂时使用一个常规函数模拟
                requestToJoinRoom(roomCode, gameState.peer.id, playerName);
            } catch (error) {
                console.error('加入房间失败:', error);
                alert('加入房间失败: ' + error.message);
                showScreen('welcome-screen');
            }
        }

        // 模拟加入房间的请求处理
        function requestToJoinRoom(roomCode, peerId, playerName) {
            // 显示连接状态
            const waitingList = document.getElementById('waiting-player-list');
            waitingList.innerHTML = '<li class="py-3">正在连接房间，请稍候...</li>';
            
            // 假设对方的ID是房间号的哈希值(在实际应用中，这个ID应该从信令服务器获取)
            // 在这个demo中，我们使用一个假设的连接方式
            // 此处需要换成真实的连接逻辑
            try {
                // 随机生成一个假的Host ID (在实际应用中不要这样做)
                const fakeHostId = "host_" + roomCode.toLowerCase();
                
                // 连接到假主机
                connectToHost(fakeHostId, playerName);
                
                // 由于这是一个假设的连接，我们添加一些模拟的延迟和UI更新
                setTimeout(() => {
                    addAIPlayers(3); // 添加一些AI玩家以演示
                    updateWaitingPlayerList();
                }, 1000);
            } catch (error) {
                console.error('连接房主失败:', error);
                waitingList.innerHTML = '<li class="py-3 text-red-500">连接房主失败，请检查房间代码是否正确</li>';
                
                // 3秒后返回欢迎屏幕
                setTimeout(() => showScreen('welcome-screen'), 3000);
            }
        }

        function connectToHost(hostId, playerName) {
            // 在实际应用中，此函数会使用PeerJS连接到房主
            console.log(`尝试连接到房主 ${hostId} 作为 ${playerName}`);
            
            // 模拟连接成功
            simulateJoinSuccess(playerName);
        }

        function simulateJoinSuccess(playerName) {
            // 模拟连接到房间成功
            gameState.players = [
                { id: "host_id", name: "房主", isHost: true, isAI: false },
                { id: gameState.peer.id, name: playerName, isHost: false, isAI: false }
            ];
            
            document.getElementById('waiting-host-name').textContent = "房主";
            updateWaitingPlayerList();
        }

        function updateWaitingPlayerList() {
            const waitingList = document.getElementById('waiting-player-list');
            waitingList.innerHTML = '';
            
            gameState.players.forEach(player => {
                const li = document.createElement('li');
                li.className = 'py-3 flex items-center';
                
                const isAI = player.isAI;
                const isYou = player.id === gameState.peer.id;
                const isHost = player.isHost;
                
                let nameDisplay = player.name;
                if (isYou) nameDisplay += ' (你)';
                if (isHost) nameDisplay = '房主 ' + nameDisplay;
                if (isAI) nameDisplay += ' [AI]';
                
                li.innerHTML = `
                    <span class="inline-block h-8 w-8 rounded-full ${isAI ? 'bg-green-500' : 'bg-primary'} text-white flex items-center justify-center mr-3">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                            <path fill-rule="evenodd" d="M10 9a3 3 0 100-6 3 3 0 000 6zm-7 9a7 7 0 1114 0H3z" clip-rule="evenodd" />
                        </svg>
                    </span>
                    <span class="font-medium">${nameDisplay}</span>
                `;
                waitingList.appendChild(li);
            });
        }

        // 添加AI玩家
        function showAddAIModal() {
            // 随机生成一个名字
            const aiNames = ['小明', '小红', '小刚', '小丽', '小华', '小芳', '小东', '小西', '小南', '小北'];
            const randomName = aiNames[Math.floor(Math.random() * aiNames.length)] + Math.floor(Math.random() * 100);
            
            document.getElementById('ai-player-name').value = randomName;
            document.getElementById('ai-player-personality').value = 'random';
            
            showModal('add-ai-modal');
        }

        function addAIPlayer() {
            const aiName = document.getElementById('ai-player-name').value.trim();
            let aiPersonality = document.getElementById('ai-player-personality').value;
            
            if (!aiName) {
                alert('请输入AI玩家名字');
                return;
            }
            
            // 如果选择随机性格，从现有性格中随机选择一个
            if (aiPersonality === 'random') {
                const personalities = Object.keys(AI_PERSONALITIES);
                aiPersonality = personalities[Math.floor(Math.random() * personalities.length)];
            }
            
            // 生成唯一ID
            const aiId = 'ai_' + Date.now() + '_' + Math.floor(Math.random() * 1000);
            
            // 添加AI玩家到玩家列表
            gameState.players.push({
                id: aiId,
                name: aiName,
                isHost: false,
                isAI: true,
                personality: aiPersonality,
                suspicions: []  // AI的怀疑目标列表
            });
            
            // 更新玩家列表并隐藏弹窗
            updatePlayerList();
            hideModal('add-ai-modal');
            
            // 如果是房主，广播玩家列表更新
            if (gameState.isHost) {
                broadcastGameState();
            }
        }

        // 用于演示的添加多个AI玩家
        function addAIPlayers(count) {
            const aiNames = ['小明', '小红', '小刚', '小丽', '小华', '小芳', '小东', '小西', '小南', '小北'];
            const personalities = Object.keys(AI_PERSONALITIES);
            
            for (let i = 0; i < count; i++) {
                const aiName = aiNames[Math.floor(Math.random() * aiNames.length)] + Math.floor(Math.random() * 100);
                const aiPersonality = personalities[Math.floor(Math.random() * personalities.length)];
                const aiId = 'ai_' + Date.now() + '_' + i;
                
                gameState.players.push({
                    id: aiId,
                    name: aiName,
                    isHost: false,
                    isAI: true,
                    personality: aiPersonality,
                    suspicions: []
                });
            }
        }

        // 广播游戏状态给所有连接的玩家
        function broadcastGameState() {
            Object.values(gameState.connections).forEach(conn => {
                conn.send({
                    type: 'game_state',
                    state: {
                        players: gameState.players,
                        roleSettings: gameState.roleSettings,
                        gamePhase: gameState.gamePhase,
                        day: gameState.day,
                        roomCode: gameState.roomCode,
                        gameStarted: gameState.gameStarted
                    }
                });
            });
        }

        // 向特定玩家发送私密信息
        function sendPrivateInfo(peerId, type, data) {
            const conn = gameState.connections[peerId];
            if (conn) {
                conn.send({
                    type: type,
                    data: data
                });
            }
        }

        // 处理收到的P2P消息
        function handlePeerMessage(peerId, message) {
            console.log('Received message:', message);
            
            switch (message.type) {
                case 'join_request':
                    // 处理加入请求
                    if (gameState.isHost && !gameState.gameStarted) {
                        // 检查名字是否已存在
                        const nameExists = gameState.players.some(p => p.name === message.playerName);
                        
                        if (nameExists) {
                            sendPrivateInfo(peerId, 'join_response', {
                                accepted: false,
                                reason: '该名字已被使用'
                            });
                        } else {
                            // 接受请求
                            gameState.players.push({
                                id: peerId,
                                name: message.playerName,
                                isHost: false,
                                isAI: false
                            });
                            
                            sendPrivateInfo(peerId, 'join_response', {
                                accepted: true,
                                state: {
                                    players: gameState.players,
                                    roleSettings: gameState.roleSettings,
                                    gamePhase: gameState.gamePhase,
                                    roomCode: gameState.roomCode,
                                    host: gameState.players[0].name
                                }
                            });
                            
                            // 更新玩家列表并广播新状态
                            updatePlayerList();
                            broadcastGameState();
                        }
                    } else {
                        // 游戏已开始，拒绝请求
                        sendPrivateInfo(peerId, 'join_response', {
                            accepted: false,
                            reason: '游戏已经开始'
                        });
                    }
                    break;
                
                case 'join_response':
                    // 处理加入响应
                    if (message.accepted) {
                        // 更新本地游戏状态
                        Object.assign(gameState, message.state);
                        
                        // 更新等待屏幕
                        document.getElementById('waiting-host-name').textContent = message.state.host;
                        updateWaitingPlayerList();
                    } else {
                        alert('加入房间失败: ' + message.reason);
                        showScreen('welcome-screen');
                    }
                    break;
                
                case 'game_state':
                    // 更新游戏状态
                    Object.assign(gameState, message.state);
                    
                    // 更新UI
                    if (gameState.gameStarted && !gameState.inited) {
                        initializeGame();
                    } else {
                        updatePlayerList();
                    }
                    break;
                
                case 'start_game':
                    // 处理游戏开始
                    gameState.gameStarted = true;
                    gameState.playerRole = message.role;
                    
                    // 初始化游戏
                    initializeGame();
                    break;
                
                case 'chat_message':
                    // 添加聊天消息
                    addChatMessage(message.playerName, message.text, message.playerId);
                    break;
                
                case 'game_action':
                    // 处理游戏动作
                    handleGameAction(message.action, message.data);
                    break;
                
                case 'game_log':
                    // 添加游戏日志
                    addToGameLog(message.text);
                    break;
                
                case 'kick':
                    // 被踢出房间
                    alert(message.message || '你已被房主移出房间');
                    leaveRoom();
                    break;
            }
        }

        // 处理游戏动作
        function handleGameAction(action, data) {
            switch (action) {
                case 'next_phase':
                    // 进入下一个游戏阶段
                    gameState.gamePhase = data.phase;
                    gameState.currentTurn = data.turn;
                    updateGamePhaseUI();
                    
                    if (data.phase === 'day_discussion') {
                        startDayPhase(data.day);
                    } else if (data.phase === 'night') {
                        startNightPhase();
                    } else if (data.phase === 'voting') {
                        startVotingPhase();
                    } else if (data.phase === 'speaking') {
                        startSpeakingPhase(data.speakingQueue);
                    }
                    break;
                
                case 'vote_result':
                    // 投票结果
                    processVoteResult(data);
                    break;
                
                case 'night_result':
                    // 夜晚结果
                    processNightResult(data);
                    break;
                
                case 'player_death':
                    // 玩家死亡
                    markPlayerDead(data.playerId, data.reason);
                    break;
                
                case 'game_over':
                    // 游戏结束
                    endGame(data.winner, data.roles);
                    break;
                
                case 'next_speaker':
                    // 下一个发言人
                    updateSpeaker(data.speakerId);
                    break;
                
                case 'special_ability_result':
                    // 特殊能力结果
                    processSpecialAbilityResult(data);
                    break;
            }
        }

        // 开始游戏
        function startGame() {
            // 检查角色配置是否正确
            updateRoleSettings();
            const totalRoles = calculateTotalRoles();
            const requiredPlayers = parseInt(document.getElementById('player-count').value);
            
            if (totalRoles !== requiredPlayers) {
                alert(`角色配置错误：配置了 ${totalRoles} 个角色，但需要 ${requiredPlayers} 个玩家`);
                return;
            }
            
            // 检查玩家数量是否足够
            if (gameState.players.length < requiredPlayers) {
                alert(`玩家不足：需要 ${requiredPlayers} 名玩家，当前只有 ${gameState.players.length} 名`);
                return;
            }
            
            // 分配角色
            const roles = assignRoles();
            gameState.gameStarted = true;
            gameState.gamePhase = 'night';
            gameState.day = 1;
            
            // 给每个玩家发送角色信息
            roles.forEach(role => {
                if (role.id === gameState.peer.id) {
                    // 自己的角色
                    gameState.playerRole = role.role;
                } else if (!role.isAI) {
                    // 发送角色信息给其他真实玩家
                    sendPrivateInfo(role.id, 'start_game', { role: role.role });
                }
            });
            
            // 广播游戏开始
            broadcastGameState();
            
            // 初始化游戏
            initializeGame();
            
            // 开始第一个夜晚
            setTimeout(() => {
                startNightPhase();
            }, 2000);
        }

        // 分配角色
        function assignRoles() {
            // 根据角色设置创建角色池
            const rolePool = [];
            
            for (const [roleId, count] of Object.entries(gameState.roleSettings)) {
                for (let i = 0; i < count; i++) {
                    rolePool.push(roleId);
                }
            }
            
            // 打乱角色池
            for (let i = rolePool.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [rolePool[i], rolePool[j]] = [rolePool[j], rolePool[i]];
            }
            
            // 分配角色给玩家
            const roles = [];
            
            gameState.players.forEach((player, index) => {
                const role = rolePool[index];
                roles.push({
                    id: player.id,
                    name: player.name,
                    isAI: player.isAI,
                    personality: player.personality,
                    role: role
                });
                
                // 如果是AI玩家，存储其角色信息
                if (player.isAI) {
                    const aiIndex = gameState.aiPlayers.findIndex(ai => ai.id === player.id);
                    if (aiIndex !== -1) {
                        gameState.aiPlayers[aiIndex].role = role;
                    } else {
                        gameState.aiPlayers.push({
                            id: player.id,
                            name: player.name,
                            role: role,
                            personality: player.personality,
                            suspicions: []
                        });
                    }
                }
            });
            
            return roles;
        }

        // 初始化游戏界面
        function initializeGame() {
            gameState.inited = true;
            
            // 显示游戏屏幕
            showScreen('game-screen');
            
            // 更新角色信息
            updateRoleInfo();
            
            // 更新玩家状态网格
            updatePlayerStatusGrid();
            
            // 清空游戏日志和聊天
            document.getElementById('game-log').innerHTML = '<p>游戏开始！</p>';
            document.getElementById('chat-messages').innerHTML = '';
            
            // 更新游戏阶段显示
            updateGamePhaseUI();
        }

        // 更新角色信息
        function updateRoleInfo() {
            if (!gameState.playerRole) return;
            
            const roleIcon = document.getElementById('role-icon');
            const roleName = document.getElementById('role-name');
            const roleTeam = document.getElementById('role-team');
            const roleDescription = document.getElementById('role-description');
            
            roleIcon.textContent = ROLE_ICONS[gameState.playerRole];
            roleName.textContent = ROLE_NAMES[gameState.playerRole];
            roleTeam.textContent = '阵营：' + ROLE_TEAMS[gameState.playerRole];
            
            // 设置角色描述
            roleDescription.querySelector('p').textContent = ROLE_DESCRIPTIONS[gameState.playerRole];
            
            // 根据角色类型设置卡片背景颜色
            const roleCard = document.querySelector('.role-card-back');
            if (['wolf', 'wolf-king', 'secret-wolf'].includes(gameState.playerRole)) {
                roleCard.classList.remove('bg-primary');
                roleCard.classList.add('bg-wolf');
            } else {
                roleCard.classList.remove('bg-wolf');
                roleCard.classList.add('bg-primary');
            }
        }

        // 更新玩家状态网格
        function updatePlayerStatusGrid() {
            const grid = document.getElementById('player-status-grid');
            grid.innerHTML = '';
            
            gameState.players.forEach(player => {
                const isAlive = !gameState.deadPlayers.includes(player.id);
                const isYou = player.id === gameState.peer.id;
                
                const playerCard = document.createElement('div');
                playerCard.className = `p-3 border rounded-lg ${isAlive ? 'bg-white dark:bg-gray-800' : 'bg-gray-200 dark:bg-gray-700'} ${isYou ? 'border-primary dark:border-primary' : 'border-gray-200 dark:border-gray-700'}`;
                
                playerCard.innerHTML = `
                    <div class="text-center mb-1">
                        <span class="inline-block h-8 w-8 rounded-full ${player.isAI ? 'bg-green-500' : 'bg-primary'} text-white flex items-center justify-center mx-auto">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                                <path fill-rule="evenodd" d="M10 9a3 3 0 100-6 3 3 0 000 6zm-7 9a7 7 0 1114 0H3z" clip-rule="evenodd" />
                            </svg>
                        </span>
                    </div>
                    <div class="text-center">
                        <p class="font-medium truncate">${player.name}${isYou ? ' (你)' : ''}</p>
                        <p class="text-xs ${isAlive ? 'text-green-600 dark:text-green-400' : 'text-red-600 dark:text-red-400'}">${isAlive ? '存活' : '死亡'}</p>
                    </div>
                `;
                
                grid.appendChild(playerCard);
            });
        }

        // 更新游戏阶段显示
        function updateGamePhaseUI() {
            const phaseIndicator = document.getElementById('game-phase-indicator');
            const chatStatus = document.getElementById('chat-status');
            
            switch (gameState.gamePhase) {
                case 'waiting':
                    phaseIndicator.textContent = '等待中';
                    phaseIndicator.className = 'ml-2 text-sm font-normal px-2 py-0.5 rounded-full bg-blue-100 text-blue-800 dark:bg-blue-900 dark:text-blue-200';
                    chatStatus.textContent = '等待游戏开始';
                    chatStatus.className = 'ml-2 text-xs font-normal px-2 py-0.5 rounded-full bg-yellow-100 text-yellow-800 dark:bg-yellow-900 dark:text-yellow-200';
                    break;
                case 'night':
                    phaseIndicator.textContent = `第${gameState.day}天 夜晚`;
                    phaseIndicator.className = 'ml-2 text-sm font-normal px-2 py-0.5 rounded-full bg-indigo-100 text-indigo-800 dark:bg-indigo-900 dark:text-indigo-200';
                    chatStatus.textContent = '夜晚禁言';
                    chatStatus.className = 'ml-2 text-xs font-normal px-2 py-0.5 rounded-full bg-red-100 text-red-800 dark:bg-red-900 dark:text-red-200';
                    
                    // 启用夜晚UI
                    document.getElementById('night-overlay').classList.remove('hidden');
                    document.getElementById('chat-input').disabled = true;
                    document.getElementById('send-chat-btn').disabled = true;
                    break;
                case 'day_discussion':
                case 'speaking':
                    phaseIndicator.textContent = `第${gameState.day}天 白天`;
                    phaseIndicator.className = 'ml-2 text-sm font-normal px-2 py-0.5 rounded-full bg-yellow-100 text-yellow-800 dark:bg-yellow-900 dark:text-yellow-200';
                    chatStatus.textContent = '白天可发言';
                    chatStatus.className = 'ml-2 text-xs font-normal px-2 py-0.5 rounded-full bg-green-100 text-green-800 dark:bg-green-900 dark:text-green-200';
                    
                    // 禁用夜晚UI
                    document.getElementById('night-overlay').classList.add('hidden');
                    
                    // 如果玩家活着，允许聊天
                    const isPlayerAlive = !gameState.deadPlayers.includes(gameState.peer.id);
                    document.getElementById('chat-input').disabled = !isPlayerAlive;
                    document.getElementById('send-chat-btn').disabled = !isPlayerAlive;
                    break;
                case 'voting':
                    phaseIndicator.textContent = `第${gameState.day}天 投票`;
                    phaseIndicator.className = 'ml-2 text-sm font-normal px-2 py-0.5 rounded-full bg-purple-100 text-purple-800 dark:bg-purple-900 dark:text-purple-200';
                    chatStatus.textContent = '投票中';
                    chatStatus.className = 'ml-2 text-xs font-normal px-2 py-0.5 rounded-full bg-orange-100 text-orange-800 dark:bg-orange-900 dark:text-orange-200';
                    
                    // 禁用夜晚UI
                    document.getElementById('night-overlay').classList.add('hidden');
                    
                    // 禁用聊天
                    document.getElementById('chat-input').disabled = true;
                    document.getElementById('send-chat-btn').disabled = true;
                    break;
                case 'game_over':
                    phaseIndicator.textContent = '游戏结束';
                    phaseIndicator.className = 'ml-2 text-sm font-normal px-2 py-0.5 rounded-full bg-gray-100 text-gray-800 dark:bg-gray-700 dark:text-gray-200';
                    chatStatus.textContent = '游戏已结束';
                    chatStatus.className = 'ml-2 text-xs font-normal px-2 py-0.5 rounded-full bg-gray-100 text-gray-800 dark:bg-gray-700 dark:text-gray-200';
                    
                    // 禁用夜晚UI
                    document.getElementById('night-overlay').classList.add('hidden');
                    
                    // 禁用聊天
                    document.getElementById('chat-input').disabled = true;
                    document.getElementById('send-chat-btn').disabled = true;
                    break;
            }
        }

        // 夜晚阶段
        function startNightPhase() {
            gameState.gamePhase = 'night';
            updateGamePhaseUI();
            
            // 隐藏白天的UI元素
            document.getElementById('speaking-turn-indicator').classList.add('hidden');
            document.getElementById('vote-area').classList.add('hidden');
            
            // 添加游戏日志
            addToGameLog(`第 ${gameState.day} 天的夜晚降临了...`);
            
            // 如果是房主，开始处理夜晚逻辑
            if (gameState.isHost) {
                processNightPhase();
            }
        }

        // 白天讨论阶段
        function startDayPhase(day) {
            gameState.gamePhase = 'day_discussion';
            gameState.day = day;
            updateGamePhaseUI();
            
            // 添加游戏日志
            addToGameLog(`第 ${day} 天的白天到来了...`);
            
            // 如果是房主，准备发言环节
            if (gameState.isHost) {
                setTimeout(() => {
                    prepareSpeakingPhase();
                }, 2000);
            }
        }

        // 准备发言环节
        function prepareSpeakingPhase() {
            // 获取所有活着的玩家
            const alivePlayers = gameState.players.filter(player => 
                !gameState.deadPlayers.includes(player.id)
            );
            
            // 随机排序发言顺序
            gameState.speakingQueue = [...alivePlayers].sort(() => Math.random() - 0.5).map(p => p.id);
            
            // 广播发言环节开始
            Object.values(gameState.connections).forEach(conn => {
                conn.send({
                    type: 'game_action',
                    action: 'next_phase',
                    data: {
                        phase: 'speaking',
                        day: gameState.day,
                        speakingQueue: gameState.speakingQueue
                    }
                });
            });
            
            // 本地也进入发言环节
            startSpeakingPhase(gameState.speakingQueue);
        }

        // 发言环节
        function startSpeakingPhase(speakingQueue) {
            gameState.gamePhase = 'speaking';
            gameState.speakingQueue = speakingQueue;
            updateGamePhaseUI();
            
            // 显示发言轮次指示器
            const speakingTurnIndicator = document.getElementById('speaking-turn-indicator');
            speakingTurnIndicator.classList.remove('hidden');
            
            // 更新发言顺序UI
            updateSpeakingOrderUI();
            
            // 开始第一个发言人
            if (gameState.isHost) {
                startNextSpeaker();
            }
        }

        // 更新发言顺序UI
        function updateSpeakingOrderUI() {
            const speakingOrder = document.getElementById('speaking-order');
            speakingOrder.innerHTML = '';
            
            gameState.speakingQueue.forEach(playerId => {
                const player = gameState.players.find(p => p.id === playerId);
                if (!player) return;
                
                const isCurrentSpeaker = playerId === gameState.currentSpeaker;
                
                const playerBadge = document.createElement('div');
                playerBadge.className = `px-3 py-1 rounded-full ${isCurrentSpeaker ? 'bg-primary text-white speaking-indicator' : 'bg-gray-200 dark:bg-gray-700 text-gray-800 dark:text-gray-200'}`;
                playerBadge.textContent = player.name;
                
                if (player.id === gameState.peer.id) {
                    playerBadge.textContent += ' (你)';
                }
                
                speakingOrder.appendChild(playerBadge);
            });
            
            // 更新发言指示文字
            const speakingInstruction = document.getElementById('speaking-instruction');
            const currentSpeaker = gameState.players.find(p => p.id === gameState.currentSpeaker);
            
            if (currentSpeaker) {
                if (currentSpeaker.id === gameState.peer.id) {
                    speakingInstruction.textContent = '现在轮到你发言，请在聊天框中输入你的发言。';
                } else {
                    speakingInstruction.textContent = `现在轮到 ${currentSpeaker.name} 发言，请等待...`;
                }
            } else {
                speakingInstruction.textContent = '准备开始发言环节...';
            }
            
            // 更新"下一位发言"按钮
            const nextSpeakerBtn = document.getElementById('next-speaker-btn');
            if (gameState.isHost || gameState.currentSpeaker === gameState.peer.id) {
                nextSpeakerBtn.classList.remove('hidden');
            } else {
                nextSpeakerBtn.classList.add('hidden');
            }
        }

        // 开始下一位发言者
        function startNextSpeaker() {
            // 如果队列为空，进入投票阶段
            if (gameState.speakingQueue.length === 0) {
                if (gameState.isHost) {
                    startVotingPhase();
                }
                return;
            }
            
            // 取队列第一个人作为当前发言者
            gameState.currentSpeaker = gameState.speakingQueue.shift();
            
            // 重置发言计时器
            gameState.speakingTimeLeft = 60;
            if (gameState.speakingTimer) {
                clearInterval(gameState.speakingTimer);
            }
            
            // 广播当前发言者
            Object.values(gameState.connections).forEach(conn => {
                conn.send({
                    type: 'game_action',
                    action: 'next_speaker',
                    data: {
                        speakerId: gameState.currentSpeaker
                    }
                });
            });
            
            // 更新发言顺序UI
            updateSpeakingOrderUI();
            
            // 添加游戏日志
            const speaker = gameState.players.find(p => p.id === gameState.currentSpeaker);
            addToGameLog(`轮到 ${speaker.name} 发言了`);
            
            // 开始计时
            startSpeakingTimer();
            
            // 如果是AI玩家，自动发言
            if (speaker && speaker.isAI) {
                // 延迟一点时间，模拟思考
                setTimeout(() => {
                    const aiIndex = gameState.aiPlayers.findIndex(ai => ai.id === speaker.id);
                    if (aiIndex !== -1) {
                        const aiPlayer = gameState.aiPlayers[aiIndex];
                        const statement = getAIStatement(aiPlayer);
                        
                        // 发送AI的聊天消息
                        broadcastChatMessage(aiPlayer.id, aiPlayer.name, statement);
                        
                        // 随机延迟后结束发言
                        const speakingTime = 5000 + Math.random() * 5000;
                        setTimeout(() => {
                            if (gameState.isHost) {
                                endCurrentSpeech();
                            }
                        }, speakingTime);
                    }
                }, 1000 + Math.random() * 2000);
            }
        }

        // 开始发言计时器
        function startSpeakingTimer() {
            const timerDisplay = document.getElementById('speaking-time-left');
            timerDisplay.textContent = gameState.speakingTimeLeft;
            
            gameState.speakingTimer = setInterval(() => {
                gameState.speakingTimeLeft--;
                timerDisplay.textContent = gameState.speakingTimeLeft;
                
                if (gameState.speakingTimeLeft <= 0) {
                    clearInterval(gameState.speakingTimer);
                    
                    // 如果是房主，结束当前发言
                    if (gameState.isHost) {
                        endCurrentSpeech();
                    }
                }
            }, 1000);
        }

        // 结束当前发言
        function endCurrentSpeech() {
            clearInterval(gameState.speakingTimer);
            
            // 广播发言结束
            Object.values(gameState.connections).forEach(conn => {
                conn.send({
                    type: 'game_log',
                    text: '发言时间结束'
                });
            });
            
            // 添加游戏日志
            addToGameLog('发言时间结束');
            
            // 开始下一位发言者
            startNextSpeaker();
        }

        // 更新当前发言者
        function updateSpeaker(speakerId) {
            gameState.currentSpeaker = speakerId;
            updateSpeakingOrderUI();
            
            // 如果当前发言者是自己，显示提示
            if (speakerId === gameState.peer.id) {
                addToGameLog('现在轮到你发言了', 'highlight');
            }
            
            // 重置发言计时器
            gameState.speakingTimeLeft = 60;
            const timerDisplay = document.getElementById('speaking-time-left');
            timerDisplay.textContent = gameState.speakingTimeLeft;
            
            if (gameState.speakingTimer) {
                clearInterval(gameState.speakingTimer);
            }
            startSpeakingTimer();
        }

        // 投票阶段
        function startVotingPhase() {
            gameState.gamePhase = 'voting';
            updateGamePhaseUI();
            
            // 隐藏发言轮次指示器
            document.getElementById('speaking-turn-indicator').classList.add('hidden');
            
            // 显示投票区域
            const voteArea = document.getElementById('vote-area');
            voteArea.classList.remove('hidden');
            
            // 添加游戏日志
            addToGameLog('投票环节开始，请选择一名玩家进行投票放逐');
            
            // 广播投票阶段开始
            if (gameState.isHost) {
                Object.values(gameState.connections).forEach(conn => {
                    conn.send({
                        type: 'game_action',
                        action: 'next_phase',
                        data: {
                            phase: 'voting',
                            day: gameState.day
                        }
                    });
                });
                
                // 重置投票
                gameState.votes = {};
                
                // 让AI玩家自动投票
                processAIVotes();
            }
            
            // 更新投票选项
            updateVoteOptions();
        }

        // 更新投票选项
        function updateVoteOptions() {
            const voteOptions = document.getElementById('vote-options');
            voteOptions.innerHTML = '';
            
            // 只显示活着的玩家
            const alivePlayers = gameState.players.filter(player => 
                !gameState.deadPlayers.includes(player.id)
            );
            
            alivePlayers.forEach(player => {
                const isYou = player.id === gameState.peer.id;
                
                const option = document.createElement('div');
                option.className = 'p-3 border rounded-lg bg-white dark:bg-gray-800 border-gray-200 dark:border-gray-700 cursor-pointer hover:border-primary dark:hover:border-primary transition';
                option.setAttribute('data-player-id', player.id);
                
                option.innerHTML = `
                    <div class="text-center mb-1">
                        <span class="inline-block h-8 w-8 rounded-full ${player.isAI ? 'bg-green-500' : 'bg-primary'} text-white flex items-center justify-center mx-auto">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                                <path fill-rule="evenodd" d="M10 9a3 3 0 100-6 3 3 0 000 6zm-7 9a7 7 0 1114 0H3z" clip-rule="evenodd" />
                            </svg>
                        </span>
                    </div>
                    <div class="text-center">
                        <p class="font-medium truncate">${player.name}${isYou ? ' (你)' : ''}</p>
                    </div>
                `;
                
                // 添加点击事件
                option.addEventListener('click', () => {
                    // 清除之前的选择
                    document.querySelectorAll('#vote-options > div').forEach(el => {
                        el.classList.remove('border-primary', 'dark:border-primary');
                        el.classList.add('border-gray-200', 'dark:border-gray-700');
                    });
                    
                    // 标记当前选择
                    option.classList.remove('border-gray-200', 'dark:border-gray-700');
                    option.classList.add('border-primary', 'dark:border-primary');
                    
                    // 保存选择
                    gameState.selectedVoteTarget = player.id;
                });
                
                voteOptions.appendChild(option);
            });
            
            // 检查玩家是否活着
            const isPlayerAlive = !gameState.deadPlayers.includes(gameState.peer.id);
            
            // 禁用/启用投票按钮
            document.getElementById('confirm-vote-btn').disabled = !isPlayerAlive;
            document.getElementById('skip-vote-btn').disabled = !isPlayerAlive;
            
            // 白痴被投票出局后可以跳过投票但不能投票
            if (gameState.playerRole === 'idiot' && gameState.deadPlayers.includes(gameState.peer.id)) {
                document.getElementById('skip-vote-btn').disabled = false;
            }
        }

        // 处理AI投票
        function processAIVotes() {
            // 获取所有活着的AI玩家
            const aliveAIs = gameState.aiPlayers.filter(ai => !gameState.deadPlayers.includes(ai.id));
            
            // 让AI玩家逐个进行投票
            aliveAIs.forEach(ai => {
                // 延迟一点时间，模拟思考
                setTimeout(() => {
                    const voteTarget = aiMakeDecision(ai, 'vote');
                    
                    if (voteTarget) {
                        // 记录投票
                        gameState.votes[ai.id] = voteTarget;
                        
                        // 找出目标玩家名称
                        const targetPlayer = gameState.players.find(p => p.id === voteTarget);
                        
                        // 添加游戏日志
                        addToGameLog(`${ai.name} 投票给了 ${targetPlayer ? targetPlayer.name : '未知玩家'}`);
                        broadcastGameLog(`${ai.name} 投票给了 ${targetPlayer ? targetPlayer.name : '未知玩家'}`);
                        
                        // 检查是否所有活着的玩家都已投票
                        checkAllVoted();
                    }
                }, 1000 + Math.random() * 3000);
            });
        }

        // 提交投票
        function submitVote() {
            if (!gameState.selectedVoteTarget) {
                alert('请选择一名玩家进行投票');
                return;
            }
            
            // 记录投票
            gameState.votes[gameState.peer.id] = gameState.selectedVoteTarget;
            
            // 找出目标玩家名称
            const targetPlayer = gameState.players.find(p => p.id === gameState.selectedVoteTarget);
            
            // 添加游戏日志
            addToGameLog(`你投票给了 ${targetPlayer ? targetPlayer.name : '未知玩家'}`);
            
            // 发送投票给房主
            if (!gameState.isHost) {
                const hostId = gameState.players.find(p => p.isHost)?.id;
                if (hostId && gameState.connections[hostId]) {
                    gameState.connections[hostId].send({
                        type: 'game_action',
                        action: 'vote',
                        data: {
                            voterId: gameState.peer.id,
                            targetId: gameState.selectedVoteTarget
                        }
                    });
                }
            } else {
                // 如果是房主，广播投票信息
                broadcastGameLog(`${gameState.playerName} 投票给了 ${targetPlayer ? targetPlayer.name : '未知玩家'}`);
                
                // 检查是否所有活着的玩家都已投票
                checkAllVoted();
            }
            
            // 禁用投票按钮
            document.getElementById('confirm-vote-btn').disabled = true;
            document.getElementById('skip-vote-btn').disabled = true;
        }

        // 跳过投票
        function skipVote() {
            // 记录弃权
            gameState.votes[gameState.peer.id] = null;
            
            // 添加游戏日志
            addToGameLog('你选择弃权');
            
            // 发送弃权给房主
            if (!gameState.isHost) {
                const hostId = gameState.players.find(p => p.isHost)?.id;
                if (hostId && gameState.connections[hostId]) {
                    gameState.connections[hostId].send({
                        type: 'game_action',
                        action: 'vote',
                        data: {
                            voterId: gameState.peer.id,
                            targetId: null
                        }
                    });
                }
            } else {
                // 如果是房主，广播弃权信息
                broadcastGameLog(`${gameState.playerName} 选择弃权`);
                
                // 检查是否所有活着的玩家都已投票
                checkAllVoted();
            }
            
            // 禁用投票按钮
            document.getElementById('confirm-vote-btn').disabled = true;
            document.getElementById('skip-vote-btn').disabled = true;
        }

        // 检查是否所有活着的玩家都已投票
        function checkAllVoted() {
            if (!gameState.isHost) return;
            
            // 获取所有活着的玩家
            const alivePlayers = gameState.players.filter(player => 
                !gameState.deadPlayers.includes(player.id)
            );
            
            // 白痴虽然"死亡"但仍可以发言，不能投票
            const canVotePlayers = alivePlayers.filter(player => {
                // 如果是白痴且已死亡，不能投票
                if (player.role === 'idiot' && gameState.deadPlayers.includes(player.id)) {
                    return false;
                }
                return true;
            });
            
            // 检查是否所有可投票的玩家都已投票
            const allVoted = canVotePlayers.every(player => 
                gameState.votes.hasOwnProperty(player.id)
            );
            
            if (allVoted) {
                // 计算投票结果
                calculateVoteResult();
            }
        }

        // 计算投票结果
        function calculateVoteResult() {
            // 统计票数
            const voteCounts = {};
            
            Object.entries(gameState.votes).forEach(([voterId, targetId]) => {
                // 忽略弃权票
                if (targetId === null) return;
                
                if (!voteCounts[targetId]) {
                    voteCounts[targetId] = 0;
                }
                voteCounts[targetId]++;
            });
            
            // 找出票数最多的玩家
            let maxVotes = 0;
            let votedOutPlayers = [];
            
            Object.entries(voteCounts).forEach(([playerId, votes]) => {
                if (votes > maxVotes) {
                    maxVotes = votes;
                    votedOutPlayers = [playerId];
                } else if (votes === maxVotes) {
                    votedOutPlayers.push(playerId);
                }
            });
            
            // 如果有平票，随机选择一个
            let votedOutPlayer = null;
            if (votedOutPlayers.length > 0) {
                if (votedOutPlayers.length === 1) {
                    votedOutPlayer = votedOutPlayers[0];
                } else {
                    // 平票随机
                    votedOutPlayer = votedOutPlayers[Math.floor(Math.random() * votedOutPlayers.length)];
                }
            }
            
            // 处理投票结果
            if (votedOutPlayer) {
                processVotedOutPlayer(votedOutPlayer, voteCounts);
            } else {
                // 没有人被投出（全部弃权）
                broadcastGameLog('所有人均弃权，没有人被放逐');
                
                // 检查游戏是否结束
                if (!checkGameEnd()) {
                    // 进入夜晚
                    setTimeout(() => {
                        startNightPhase();
                    }, 3000);
                }
            }
        }

        // 处理被投票出局的玩家
        function processVotedOutPlayer(playerId, voteCounts) {
            const player = gameState.players.find(p => p.id === playerId);
            if (!player) return;
            
            // 添加游戏日志
            const voteCount = voteCounts[playerId];
            broadcastGameLog(`${player.name} 获得了最多的票数(${voteCount}票)，被村民放逐`);
            
            // 标记玩家死亡
            markPlayerDead(playerId, 'voted');
            
            // 检查是否为特殊角色
            if (player.role === 'wolf-king') {
                // 狼王被投出，可以带走一个人
                processWolfKingAbility(player);
            } else if (player.role === 'hunter') {
                // 猎人被投出，可以带走一个人
                processHunterAbility(player);
            } else if (player.role === 'idiot') {
                // 白痴被投出，依然可以发言，但失去投票权
                broadcastGameLog(`${player.name} 是白痴，被放逐后仍可以发言，但失去了投票权`);
                
                // 特殊处理：白痴不会真正死亡，只是失去投票权
                gameState.deadPlayers = gameState.deadPlayers.filter(id => id !== playerId);
                gameState.spectators.push(playerId);
            }
            
            // 检查游戏是否结束
            if (!checkGameEnd()) {
                // 进入夜晚
                setTimeout(() => {
                    startNightPhase();
                }, 3000);
            }
        }

        // 处理狼王能力
        function processWolfKingAbility(player) {
            // 标记狼王死亡
            gameState.wolfKingDead = true;
            
            // 广播狼王身份
            broadcastGameLog(`${player.name} 是狼王！死前他可以带走一名玩家...`);
            
            // 如果是AI狼王
            if (player.isAI) {
                // AI做出决策
                const aiIndex = gameState.aiPlayers.findIndex(ai => ai.id === player.id);
                if (aiIndex !== -1) {
                    const aiPlayer = gameState.aiPlayers[aiIndex];
                    const targetId = aiMakeDecision(aiPlayer, 'wolf_king_howl');
                    
                    if (targetId) {
                        const targetPlayer = gameState.players.find(p => p.id === targetId);
                        if (targetPlayer) {
                            // 广播狼王带走信息
                            broadcastGameLog(`狼王 ${player.name} 嚎叫着带走了 ${targetPlayer.name}！`);
                            
                            // 标记目标玩家死亡
                            markPlayerDead(targetId, 'wolf_king');
                        }
                    }
                }
            } 
            // 如果是玩家狼王且是自己
            else if (player.id === gameState.peer.id) {
                // 显示能力使用界面
                showAbilityArea('狼王技能', '选择一名玩家带走：', 'wolf_king_howl');
            } 
            // 如果是其他玩家狼王
            else {
                // 等待狼王选择
                broadcastGameLog('等待狼王选择一名玩家带走...');
            }
        }

        // 处理猎人能力
        function processHunterAbility(player) {
            // 标记猎人死亡
            gameState.hunterDead = true;
            
            // 广播猎人身份
            broadcastGameLog(`${player.name} 是猎人！死前他可以开枪带走一名玩家...`);
            
            // 如果是AI猎人
            if (player.isAI) {
                // AI做出决策
                const aiIndex = gameState.aiPlayers.findIndex(ai => ai.id === player.id);
                if (aiIndex !== -1) {
                    const aiPlayer = gameState.aiPlayers[aiIndex];
                    const targetId = aiMakeDecision(aiPlayer, 'hunter_shoot');
                    
                    if (targetId) {
                        const targetPlayer = gameState.players.find(p => p.id === targetId);
                        if (targetPlayer) {
                            // 广播猎人开枪信息
                            broadcastGameLog(`猎人 ${player.name} 开枪打中了 ${targetPlayer.name}！`);
                            
                            // 标记目标玩家死亡
                            markPlayerDead(targetId, 'hunter');
                        }
                    }
                }
            } 
            // 如果是玩家猎人且是自己
            else if (player.id === gameState.peer.id) {
                // 显示能力使用界面
                showAbilityArea('猎人技能', '选择一名玩家射杀：', 'hunter_shoot');
            } 
            // 如果是其他玩家猎人
            else {
                // 等待猎人选择
                broadcastGameLog('等待猎人选择一名玩家射杀...');
            }
        }

        // 显示能力使用区域
        function showAbilityArea(title, instruction, abilityType) {
            const abilityArea = document.getElementById('ability-area');
            const abilityTitle = document.getElementById('ability-title');
            const abilityInstruction = document.getElementById('ability-instruction');
            const abilityOptions = document.getElementById('ability-options');
            
            // 设置标题和说明
            abilityTitle.textContent = title;
            abilityInstruction.textContent = instruction;
            
            // 清空选项
            abilityOptions.innerHTML = '';
            
            // 获取所有活着的玩家作为目标
            const alivePlayers = gameState.players.filter(player => 
                !gameState.deadPlayers.includes(player.id) && player.id !== gameState.peer.id
            );
            
            // 如果是女巫使用毒药，包括自己
            if (abilityType === 'witch_poison') {
                const selfPlayer = gameState.players.find(p => p.id === gameState.peer.id);
                if (selfPlayer && !gameState.deadPlayers.includes(selfPlayer.id)) {
                    alivePlayers.push(selfPlayer);
                }
            }
            
            // 添加玩家选项
            alivePlayers.forEach(player => {
                const option = document.createElement('div');
                option.className = 'p-3 border rounded-lg bg-white dark:bg-gray-800 border-gray-200 dark:border-gray-700 cursor-pointer hover:border-primary dark:hover:border-primary transition';
                option.setAttribute('data-player-id', player.id);
                
                option.innerHTML = `
                    <div class="text-center mb-1">
                        <span class="inline-block h-8 w-8 rounded-full ${player.isAI ? 'bg-green-500' : 'bg-primary'} text-white flex items-center justify-center mx-auto">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                                <path fill-rule="evenodd" d="M10 9a3 3 0 100-6 3 3 0 000 6zm-7 9a7 7 0 1114 0H3z" clip-rule="evenodd" />
                            </svg>
                        </span>
                    </div>
                    <div class="text-center">
                        <p class="font-medium truncate">${player.name}${player.id === gameState.peer.id ? ' (你)' : ''}</p>
                    </div>
                `;
                
                // 添加点击事件
                option.addEventListener('click', () => {
                    // 清除之前的选择
                    document.querySelectorAll('#ability-options > div').forEach(el => {
                        el.classList.remove('border-primary', 'dark:border-primary');
                        el.classList.add('border-gray-200', 'dark:border-gray-700');
                    });
                    
                    // 标记当前选择
                    option.classList.remove('border-gray-200', 'dark:border-gray-700');
                    option.classList.add('border-primary', 'dark:border-primary');
                    
                    // 保存选择
                    gameState.selectedAbilityTarget = player.id;
                });
                
                abilityOptions.appendChild(option);
            });
            
            // 设置确认按钮事件
            const confirmBtn = document.getElementById('confirm-ability-btn');
            confirmBtn.onclick = () => {
                if (!gameState.selectedAbilityTarget) {
                    alert('请选择一名玩家');
                    return;
                }
                
                // 使用能力
                useAbility(abilityType, gameState.selectedAbilityTarget);
                
                // 隐藏能力区域
                abilityArea.classList.add('hidden');
            };
            
            // 设置跳过按钮事件
            const skipBtn = document.getElementById('skip-ability-btn');
            skipBtn.onclick = () => {
                // 跳过使用能力
                useAbility(abilityType, null);
                
                // 隐藏能力区域
                abilityArea.classList.add('hidden');
            };
            
            // 显示能力区域
            abilityArea.classList.remove('hidden');
        }

        // 使用能力
        function useAbility(abilityType, targetId) {
            switch (abilityType) {
                case 'wolf_kill':
                    // 狼人杀人
                    if (gameState.isHost) {
                        gameState.wolfVotes[gameState.peer.id] = targetId;
                        checkAllWolvesVoted();
                    } else {
                        // 发送给房主
                        const hostId = gameState.players.find(p => p.isHost)?.id;
                        if (hostId && gameState.connections[hostId]) {
                            gameState.connections[hostId].send({
                                type: 'game_action',
                                action: 'wolf_kill',
                                data: {
                                    wolfId: gameState.peer.id,
                                    targetId: targetId
                                }
                            });
                        }
                    }
                    
                    // 更新夜晚消息
                    document.getElementById('night-message').textContent = targetId ? '你选择了猎杀目标，请等待其他狼人决定...' : '你选择跳过本轮杀人';
                    break;
                
                case 'witch_save':
                    // 女巫救人
                    if (gameState.isHost) {
                        gameState.witchSaveTarget = targetId;
                        
                        if (targetId) {
                            gameState.savedByWitch = true;
                            addToGameLog('你使用解药救了被狼人袭击的人');
                        } else {
                            addToGameLog('你选择不使用解药');
                        }
                        
                        // 标记解药已使用
                        gameState.witchSaveUsed = targetId !== null;
                        
                        // 如果女巫是房主，继续女巫的第二个选择（毒药）
                        processWitchPoisonPhase();
                    } else {
                        // 发送给房主
                        const hostId = gameState.players.find(p => p.isHost)?.id;
                        if (hostId && gameState.connections[hostId]) {
                            gameState.connections[hostId].send({
                                type: 'game_action',
                                action: 'witch_save',
                                data: {
                                    witchId: gameState.peer.id,
                                    save: targetId !== null
                                }
                            });
                        }
                    }
                    
                    // 更新夜晚消息
                    document.getElementById('night-message').textContent = targetId !== null ? '你使用了解药' : '你选择不使用解药';
                    break;
                
                case 'witch_poison':
                    // 女巫毒人
                    if (gameState.isHost) {
                        gameState.witchPoisonTarget = targetId;
                        
                        if (targetId) {
                            const targetPlayer = gameState.players.find(p => p.id === targetId);
                            addToGameLog(`你使用毒药毒死了 ${targetPlayer ? targetPlayer.name : '某人'}`);
                        } else {
                            addToGameLog('你选择不使用毒药');
                        }
                        
                        // 标记毒药已使用
                        gameState.witchPoisonUsed = targetId !== null;
                        
                        // 继续处理夜晚阶段
                        processNextNightRole();
                    } else {
                        // 发送给房主
                        const hostId = gameState.players.find(p => p.isHost)?.id;
                        if (hostId && gameState.connections[hostId]) {
                            gameState.connections[hostId].send({
                                type: 'game_action',
                                action: 'witch_poison',
                                data: {
                                    witchId: gameState.peer.id,
                                    targetId: targetId
                                }
                            });
                        }
                    }
                    
                    // 更新夜晚消息
                    document.getElementById('night-message').textContent = targetId ? '你使用了毒药' : '你选择不使用毒药';
                    break;
                
                case 'seer_check':
                    // 预言家查验
                    if (gameState.isHost) {
                        gameState.seerTarget = targetId;
                        
                        if (targetId) {
                            const targetPlayer = gameState.players.find(p => p.id === targetId);
                            const isWolf = ['wolf', 'wolf-king'].includes(targetPlayer?.role);
                            
                            // 隐狼对预言家查验显示为好人
                            const isFakeGood = targetPlayer?.role === 'secret-wolf';
                            
                            if (targetPlayer) {
                                if (isWolf && !isFakeGood) {
                                    addToGameLog(`你查验的结果：${targetPlayer.name} 是狼人`);
                                } else {
                                    addToGameLog(`你查验的结果：${targetPlayer.name} 是好人`);
                                }
                            }
                        } else {
                            addToGameLog('你选择跳过查验');
                        }
                        
                        // 继续处理夜晚阶段
                        processNextNightRole();
                    } else {
                        // 发送给房主
                        const hostId = gameState.players.find(p => p.isHost)?.id;
                        if (hostId && gameState.connections[hostId]) {
                            gameState.connections[hostId].send({
                                type: 'game_action',
                                action: 'seer_check',
                                data: {
                                    seerId: gameState.peer.id,
                                    targetId: targetId
                                }
                            });
                        }
                    }
                    
                    // 更新夜晚消息
                    document.getElementById('night-message').textContent = targetId ? '你正在查验中...' : '你选择跳过查验';
                    break;
                
                case 'guard_protect':
                    // 守卫保护
                    if (gameState.isHost) {
                        // 检查是否连续两晚保护同一个人
                        if (targetId && targetId === gameState.lastGuardTarget) {
                            alert('你不能连续两晚保护同一个人');
                            return;
                        }
                        
                        gameState.guardTarget = targetId;
                        gameState.lastGuardTarget = targetId;
                        
                        if (targetId) {
                            const targetPlayer = gameState.players.find(p => p.id === targetId);
                            addToGameLog(`你选择保护 ${targetPlayer ? targetPlayer.name : '某人'}`);
                        } else {
                            addToGameLog('你选择不保护任何人');
                        }
                        
                        // 继续处理夜晚阶段
                        processNextNightRole();
                    } else {
                        // 发送给房主
                        const hostId = gameState.players.find(p => p.isHost)?.id;
                        if (hostId && gameState.connections[hostId]) {
                            gameState.connections[hostId].send({
                                type: 'game_action',
                                action: 'guard_protect',
                                data: {
                                    guardId: gameState.peer.id,
                                    targetId: targetId,
                                    lastTarget: gameState.lastGuardTarget
                                }
                            });
                        }
                    }
                    
                    // 更新夜晚消息
                    document.getElementById('night-message').textContent = targetId ? '你选择了守护目标' : '你选择不守护任何人';
                    break;
                
                case 'wolf_king_howl':
                    // 狼王带走技能
                    if (targetId) {
                        const targetPlayer = gameState.players.find(p => p.id === targetId);
                        
                        // 发送给房主
                        if (!gameState.isHost) {
                            const hostId = gameState.players.find(p => p.isHost)?.id;
                            if (hostId && gameState.connections[hostId]) {
                                gameState.connections[hostId].send({
                                    type: 'game_action',
                                    action: 'wolf_king_howl',
                                    data: {
                                        wolfKingId: gameState.peer.id,
                                        targetId: targetId
                                    }
                                });
                            }
                        } else {
                            // 如果房主是狼王
                            broadcastGameLog(`狼王 ${gameState.playerName} 嚎叫着带走了 ${targetPlayer ? targetPlayer.name : '某人'}！`);
                            markPlayerDead(targetId, 'wolf_king');
                        }
                    } else {
                        // 发送跳过
                        if (!gameState.isHost) {
                            const hostId = gameState.players.find(p => p.isHost)?.id;
                            if (hostId && gameState.connections[hostId]) {
                                gameState.connections[hostId].send({
                                    type: 'game_action',
                                    action: 'wolf_king_howl',
                                    data: {
                                        wolfKingId: gameState.peer.id,
                                        targetId: null
                                    }
                                });
                            }
                        } else {
                            // 房主狼王跳过
                            broadcastGameLog(`狼王 ${gameState.playerName} 放弃了带走任何人`);
                        }
                    }
                    break;
                
                case 'hunter_shoot':
                    // 猎人射杀技能
                    if (targetId) {
                        const targetPlayer = gameState.players.find(p => p.id === targetId);
                        
                        // 发送给房主
                        if (!gameState.isHost) {
                            const hostId = gameState.players.find(p => p.isHost)?.id;
                            if (hostId && gameState.connections[hostId]) {
                                gameState.connections[hostId].send({
                                    type: 'game_action',
                                    action: 'hunter_shoot',
                                    data: {
                                        hunterId: gameState.peer.id,
                                        targetId: targetId
                                    }
                                });
                            }
                        } else {
                            // 如果房主是猎人
                            broadcastGameLog(`猎人 ${gameState.playerName} 开枪打中了 ${targetPlayer ? targetPlayer.name : '某人'}！`);
                            markPlayerDead(targetId, 'hunter');
                        }
                    } else {
                        // 发送跳过
                        if (!gameState.isHost) {
                            const hostId = gameState.players.find(p => p.isHost)?.id;
                            if (hostId && gameState.connections[hostId]) {
                                gameState.connections[hostId].send({
                                    type: 'game_action',
                                    action: 'hunter_shoot',
                                    data: {
                                        hunterId: gameState.peer.id,
                                        targetId: null
                                    }
                                });
                            }
                        } else {
                            // 房主猎人跳过
                            broadcastGameLog(`猎人 ${gameState.playerName} 放弃了开枪`);
                        }
                    }
                    break;
            }
        }

        // 向狼人显示可用的袭击目标
        function showWolfKillOptions() {
            // 获取所有活着的非狼人玩家
            const targets = gameState.players.filter(player => 
                !gameState.deadPlayers.includes(player.id) && 
                !['wolf', 'wolf-king', 'secret-wolf'].includes(player.role)
            );
            
            // 显示能力使用界面
            showAbilityArea('狼人杀人', '选择一名玩家袭击：', 'wolf_kill');
            
            // 更新夜晚消息
            document.getElementById('night-message').textContent = '狼人请睁眼，选择你要袭击的目标';
        }

        // 女巫获取被狼人袭击的信息
        function notifyWitchOfWolfTarget(witchId) {
            const witch = gameState.players.find(p => p.id === witchId);
            
            // 如果女巫没有解药，跳过救人环节
            if (gameState.witchSaveUsed) {
                // 如果是AI女巫，直接进入下一步
                if (witch.isAI) {
                    if (gameState.isHost) {
                        processWitchPoisonPhase();
                    }
                } else {
                    // 告知玩家女巫解药已用完
                    sendPrivateInfo(witchId, 'game_action', {
                        action: 'witch_info',
                        data: {
                            message: '你的解药已经用完了',
                            phase: 'poison'
                        }
                    });
                }
                return;
            }
            
            // 获取狼人袭击目标
            const targetPlayer = gameState.players.find(p => p.id === gameState.killedAtNight);
            
            // 如果是AI女巫
            if (witch.isAI) {
                // 记录在AI玩家状态中
                const aiIndex = gameState.aiPlayers.findIndex(ai => ai.id === witchId);
                if (aiIndex !== -1) {
                    gameState.aiPlayers[aiIndex].witchSaveUsed = false;
                    gameState.aiPlayers[aiIndex].witchPoisonUsed = false;
                    
                    // AI决策是否救人
                    const saveDecision = aiMakeDecision(gameState.aiPlayers[aiIndex], 'witch_save');
                    gameState.savedByWitch = saveDecision;
                    gameState.witchSaveUsed = saveDecision;
                    gameState.aiPlayers[aiIndex].witchSaveUsed = saveDecision;
                    
                    // 继续处理女巫毒人
                    if (gameState.isHost) {
                        processWitchPoisonPhase();
                    }
                }
            } else {
                // 发送给玩家女巫
                sendPrivateInfo(witchId, 'game_action', {
                    action: 'witch_info',
                    data: {
                        killedPlayer: targetPlayer ? targetPlayer.name : null,
                        killedPlayerId: gameState.killedAtNight,
                        phase: 'save'
                    }
                });
            }
        }

        // 女巫决定是否使用毒药
        function processWitchPoisonPhase() {
            // 获取女巫
            const witch = gameState.players.find(p => p.role === 'witch' && !gameState.deadPlayers.includes(p.id));
            
            // 如果没有女巫或毒药已用完，跳过
            if (!witch || gameState.witchPoisonUsed) {
                processNextNightRole();
                return;
            }
            
            // 如果是AI女巫
            if (witch.isAI) {
                // AI决策是否使用毒药
                const aiIndex = gameState.aiPlayers.findIndex(ai => ai.id === witch.id);
                if (aiIndex !== -1) {
                    const poisonTarget = aiMakeDecision(gameState.aiPlayers[aiIndex], 'witch_poison');
                    gameState.witchPoisonTarget = poisonTarget;
                    gameState.witchPoisonUsed = poisonTarget !== null;
                    gameState.aiPlayers[aiIndex].witchPoisonUsed = poisonTarget !== null;
                    
                    // 继续处理夜晚阶段
                    processNextNightRole();
                }
            } else if (witch.id === gameState.peer.id) {
                // 是玩家自己
                showAbilityArea('女巫毒药', '选择一名玩家毒死：', 'witch_poison');
                
                // 更新夜晚消息
                document.getElementById('night-message').textContent = '你可以使用毒药...';
            } else {
                // 通知玩家女巫
                sendPrivateInfo(witch.id, 'game_action', {
                    action: 'witch_info',
                    data: {
                        phase: 'poison'
                    }
                });
            }
        }

        // 预言家查验
        function processSeerCheck() {
            // 获取预言家
            const seer = gameState.players.find(p => p.role === 'seer' && !gameState.deadPlayers.includes(p.id));
            
            // 如果没有预言家，跳过
            if (!seer) {
                processNextNightRole();
                return;
            }
            
            // 如果是AI预言家
            if (seer.isAI) {
                // AI决策查验目标
                const aiIndex = gameState.aiPlayers.findIndex(ai => ai.id === seer.id);
                if (aiIndex !== -1) {
                    const checkTarget = aiMakeDecision(gameState.aiPlayers[aiIndex], 'seer_check');
                    gameState.seerTarget = checkTarget;
                    
                    if (checkTarget) {
                        // 保存查验结果
                        const targetPlayer = gameState.players.find(p => p.id === checkTarget);
                        if (targetPlayer) {
                            // 判断是否为狼（隐狼显示为好人）
                            const isWolf = ['wolf', 'wolf-king'].includes(targetPlayer.role);
                            const isFakeGood = targetPlayer.role === 'secret-wolf';
                            
                            if (!gameState.aiPlayers[aiIndex].seerResults) {
                                gameState.aiPlayers[aiIndex].seerResults = [];
                            }
                            
                            gameState.aiPlayers[aiIndex].seerResults.push({
                                playerName: targetPlayer.name,
                                playerId: targetPlayer.id,
                                isWolf: isWolf && !isFakeGood
                            });
                            
                            // 如果查到狼，添加到怀疑列表
                            if (isWolf && !isFakeGood) {
                                if (!gameState.aiPlayers[aiIndex].suspicions) {
                                    gameState.aiPlayers[aiIndex].suspicions = [];
                                }
                                if (!gameState.aiPlayers[aiIndex].suspicions.includes(targetPlayer.id)) {
                                    gameState.aiPlayers[aiIndex].suspicions.push(targetPlayer.id);
                                }
                            }
                        }
                    }
                    
                    // 继续处理夜晚阶段
                    processNextNightRole();
                }
            } else if (seer.id === gameState.peer.id) {
                // 是玩家自己
                showAbilityArea('预言家查验', '选择一名玩家查验：', 'seer_check');
                
                // 更新夜晚消息
                document.getElementById('night-message').textContent = '预言家请睁眼，你要查验谁？';
            } else {
                // 通知玩家预言家
                sendPrivateInfo(seer.id, 'game_action', {
                    action: 'seer_turn'
                });
            }
        }

        // 守卫保护
        function processGuardProtect() {
            // 获取守卫
            const guard = gameState.players.find(p => p.role === 'guard' && !gameState.deadPlayers.includes(p.id));
            
            // 如果没有守卫，跳过
            if (!guard) {
                processNextNightRole();
                return;
            }
            
            // 如果是AI守卫
            if (guard.isAI) {
                // AI决策保护目标
                const aiIndex = gameState.aiPlayers.findIndex(ai => ai.id === guard.id);
                if (aiIndex !== -1) {
                    // 确保不连续两晚保护同一个人
                    let protectTarget = aiMakeDecision(gameState.aiPlayers[aiIndex], 'guard_protect');
                    
                    if (protectTarget === gameState.lastGuardTarget) {
                        // 随机选择另一个目标
                        const otherTargets = gameState.players.filter(p => 
                            !gameState.deadPlayers.includes(p.id) && 
                            p.id !== guard.id && 
                            p.id !== gameState.lastGuardTarget
                        );
                        
                        if (otherTargets.length > 0) {
                            protectTarget = otherTargets[Math.floor(Math.random() * otherTargets.length)].id;
                        } else {
                            protectTarget = null; // 没有其他可选目标
                        }
                    }
                    
                    gameState.guardTarget = protectTarget;
                    gameState.lastGuardTarget = protectTarget;
                    
                    // 继续处理夜晚阶段
                    processNextNightRole();
                }
            } else if (guard.id === gameState.peer.id) {
                // 是玩家自己
                showAbilityArea('守卫保护', '选择一名玩家保护：', 'guard_protect');
                
                // 更新夜晚消息
                document.getElementById('night-message').textContent = '守卫请睁眼，你要保护谁？';
            } else {
                // 通知玩家守卫
                sendPrivateInfo(guard.id, 'game_action', {
                    action: 'guard_turn',
                    data: {
                        lastTarget: gameState.lastGuardTarget
                    }
                });
            }
        }

        // 夜晚阶段处理
        function processNightPhase() {
            // 初始化夜晚数据
            gameState.wolfVotes = {};
            gameState.killedAtNight = null;
            gameState.savedByWitch = false;
            gameState.poisonedByWitch = null;
            gameState.guardTarget = null;
            
            // 处理狼人杀人
            processWolfKillPhase();
        }

        // 狼人杀人阶段
        function processWolfKillPhase() {
            // 获取所有活着的狼人
            const wolves = gameState.players.filter(player => 
                !gameState.deadPlayers.includes(player.id) && 
                ['wolf', 'wolf-king', 'secret-wolf'].includes(player.role)
            );
            
            // 如果没有狼人了，直接进入白天
            if (wolves.length === 0) {
                startDayPhase(gameState.day + 1);
                return;
            }
            
            // 广播狼人回合
            broadcastGameLog('狼人们正在选择袭击目标...');
            
            // 通知所有活着的狼人
            wolves.forEach(wolf => {
                if (wolf.isAI) {
                    // AI狼人决策
                    const aiIndex = gameState.aiPlayers.findIndex(ai => ai.id === wolf.id);
                    if (aiIndex !== -1) {
                        const target = aiMakeDecision(gameState.aiPlayers[aiIndex], 'wolf_kill');
                        gameState.wolfVotes[wolf.id] = target;
                    }
                } else if (wolf.id === gameState.peer.id) {
                    // 是玩家自己
                    showWolfKillOptions();
                } else {
                    // 其他玩家狼
                    sendPrivateInfo(wolf.id, 'game_action', {
                        action: 'wolf_turn'
                    });
                }
            });
            
            // 检查是否所有狼人都已投票
            checkAllWolvesVoted();
        }

        // 检查是否所有狼人都已投票
        function checkAllWolvesVoted() {
            // 获取所有活着的狼人
            const wolves = gameState.players.filter(player => 
                !gameState.deadPlayers.includes(player.id) && 
                ['wolf', 'wolf-king', 'secret-wolf'].includes(player.role)
            );
            
            // 检查是否所有狼人都已投票
            const allVoted = wolves.every(wolf => gameState.wolfVotes.hasOwnProperty(wolf.id));
            
            if (allVoted) {
                // 计算杀人结果
                calculateWolfKillResult();
            }
        }

        // 计算狼人杀人结果
        function calculateWolfKillResult() {
            // 统计票数
            const voteCounts = {};
            let maxVotes = 0;
            let targets = [];
            
            Object.values(gameState.wolfVotes).forEach(targetId => {
                // 忽略弃权票
                if (targetId === null) return;
                
                if (!voteCounts[targetId]) {
                    voteCounts[targetId] = 0;
                }
                voteCounts[targetId]++;
                
                if (voteCounts[targetId] > maxVotes) {
                    maxVotes = voteCounts[targetId];
                    targets = [targetId];
                } else if (voteCounts[targetId] === maxVotes) {
                    targets.push(targetId);
                }
            });
            
            // 如果有目标，随机选择一个
            if (targets.length > 0) {
                gameState.killedAtNight = targets[Math.floor(Math.random() * targets.length)];
            }
            
            // 处理女巫救人阶段
            processWitchSavePhase();
        }

        // 女巫救人阶段
        function processWitchSavePhase() {
            // 获取女巫
            const witch = gameState.players.find(p => p.role === 'witch' && !gameState.deadPlayers.includes(p.id));
            
            // 如果没有女巫或没有人被杀，跳过
            if (!witch || !gameState.killedAtNight) {
                processNextNightRole();
                return;
            }
            
            // 通知女巫
            notifyWitchOfWolfTarget(witch.id);
        }

        // 处理下一个夜晚角色行动
        function processNextNightRole() {
            // 判断当前阶段
            if (gameState.seerTarget === undefined) {
                // 预言家还没行动
                processSeerCheck();
            } else if (gameState.guardTarget === undefined) {
                // 守卫还没行动
                processGuardProtect();
            } else {
                // 所有角色都行动完了，计算夜晚结果
                calculateNightResult();
            }
        }

        // 计算夜晚结果
        function calculateNightResult() {
            let nightDeaths = [];
            
            // 处理狼人杀人
            if (gameState.killedAtNight) {
                // 检查是否被女巫救了
                if (gameState.savedByWitch) {
                    // 被女巫救了，不死
                } 
                // 检查是否被守卫保护了
                else if (gameState.guardTarget === gameState.killedAtNight) {
                    // 被守卫保护了，不死
                } 
                else {
                    // 被狼人杀死
                    nightDeaths.push({
                        playerId: gameState.killedAtNight,
                        reason: 'wolf'
                    });
                }
            }
            
            // 处理女巫毒人
            if (gameState.witchPoisonTarget) {
                nightDeaths.push({
                    playerId: gameState.witchPoisonTarget,
                    reason: 'witch'
                });
            }
            
            // 进入白天
            if (gameState.isHost) {
                // 先处理死亡
                nightDeaths.forEach(death => {
                    markPlayerDead(death.playerId, death.reason);
                });
                
                // 检查游戏是否结束
                if (!checkGameEnd()) {
                    // 进入白天
                    setTimeout(() => {
                        // 广播白天开始
                        Object.values(gameState.connections).forEach(conn => {
                            conn.send({
                                type: 'game_action',
                                action: 'next_phase',
                                data: {
                                    phase: 'day_discussion',
                                    day: gameState.day + 1
                                }
                            });
                        });
                        
                        // 本地也进入白天
                        startDayPhase(gameState.day + 1);
                    }, 3000);
                }
            }
        }

        // 标记玩家死亡
        function markPlayerDead(playerId, reason) {
            if (!playerId || gameState.deadPlayers.includes(playerId)) return;
            
            // 添加到死亡列表
            gameState.deadPlayers.push(playerId);
            
            // 获取玩家信息
            const player = gameState.players.find(p => p.id === playerId);
            if (!player) return;
            
            // 判断死亡原因对应的描述
            let deathMessage = '';
            switch (reason) {
                case 'wolf':
                    deathMessage = `${player.name} 被狼人杀死了`;
                    break;
                case 'witch':
                    deathMessage = `${player.name} 被女巫毒死了`;
                    break;
                case 'voted':
                    deathMessage = `${player.name} 被村民投票放逐了`;
                    break;
                case 'hunter':
                    deathMessage = `${player.name} 被猎人射杀了`;
                    break;
                case 'wolf_king':
                    deathMessage = `${player.name} 被狼王带走了`;
                    break;
                default:
                    deathMessage = `${player.name} 死亡了`;
            }
            
            // 广播死亡消息
            broadcastGameLog(deathMessage);
            
            // 特殊情况：白痴被投票
            if (player.role === 'idiot' && reason === 'voted') {
                // 白痴被投票后仍可以发言但不能投票
                gameState.deadPlayers = gameState.deadPlayers.filter(id => id !== playerId);
                gameState.spectators.push(playerId);
                
                broadcastGameLog(`${player.name} 是白痴，被放逐后仍可以发言，但失去了投票权`);
            }
            
            // 更新玩家状态
            updatePlayerStatusGrid();
            
            // 如果是猎人死亡
            if (player.role === 'hunter' && !gameState.hunterDead &&
                (reason === 'wolf' || reason === 'witch')) {
                gameState.hunterDead = true;
                broadcastGameLog(`${player.name} 是猎人！死前他可以开枪带走一名玩家...`);
                
                // 如果是AI猎人
                if (player.isAI) {
                    const aiIndex = gameState.aiPlayers.findIndex(ai => ai.id === player.id);
                    if (aiIndex !== -1) {
                        const aiPlayer = gameState.aiPlayers[aiIndex];
                        const targetId = aiMakeDecision(aiPlayer, 'hunter_shoot');
                        
                        if (targetId) {
                            const targetPlayer = gameState.players.find(p => p.id === targetId);
                            if (targetPlayer) {
                                broadcastGameLog(`猎人 ${player.name} 开枪打中了 ${targetPlayer.name}！`);
                                markPlayerDead(targetId, 'hunter');
                            }
                        } else {
                            broadcastGameLog(`猎人 ${player.name} 放弃了开枪`);
                        }
                    }
                } 
                // 如果是玩家猎人
                else if (player.id === gameState.peer.id) {
                    showAbilityArea('猎人技能', '选择一名玩家射杀：', 'hunter_shoot');
                } 
                // 如果是其他玩家猎人
                else {
                    sendPrivateInfo(player.id, 'game_action', {
                        action: 'hunter_turn'
                    });
                }
            }
            
            // 如果是狼王死亡
            if (player.role === 'wolf-king' && !gameState.wolfKingDead &&
                (reason === 'wolf' || reason === 'witch')) {
                gameState.wolfKingDead = true;
                broadcastGameLog(`${player.name} 是狼王！死前他可以带走一名玩家...`);
                
                // 如果是AI狼王
                if (player.isAI) {
                    const aiIndex = gameState.aiPlayers.findIndex(ai => ai.id === player.id);
                    if (aiIndex !== -1) {
                        const aiPlayer = gameState.aiPlayers[aiIndex];
                        const targetId = aiMakeDecision(aiPlayer, 'wolf_king_howl');
                        
                        if (targetId) {
                            const targetPlayer = gameState.players.find(p => p.id === targetId);
                            if (targetPlayer) {
                                broadcastGameLog(`狼王 ${player.name} 嚎叫着带走了 ${targetPlayer.name}！`);
                                markPlayerDead(targetId, 'wolf_king');
                            }
                        } else {
                            broadcastGameLog(`狼王 ${player.name} 放弃了带走任何人`);
                        }
                    }
                } 
                // 如果是玩家狼王
                else if (player.id === gameState.peer.id) {
                    showAbilityArea('狼王技能', '选择一名玩家带走：', 'wolf_king_howl');
                } 
                // 如果是其他玩家狼王
                else {
                    sendPrivateInfo(player.id, 'game_action', {
                        action: 'wolf_king_turn'
                    });
                }
            }
            
            // 更新人数统计
            updateTeamCounts();
        }

        // 更新阵营人数统计
        function updateTeamCounts() {
            // 计算活着的好人数量
            gameState.villagerCount = gameState.players.filter(player => 
                !gameState.deadPlayers.includes(player.id) && 
                !['wolf', 'wolf-king', 'secret-wolf'].includes(player.role)
            ).length;
            
            // 计算活着的狼人数量
            gameState.wolfCount = gameState.players.filter(player => 
                !gameState.deadPlayers.includes(player.id) && 
                ['wolf', 'wolf-king', 'secret-wolf'].includes(player.role)
            ).length;
        }

        // 检查游戏是否结束
        function checkGameEnd() {
            // 更新人数统计
            updateTeamCounts();
            
            // 判断胜利条件
            if (gameState.wolfCount === 0) {
                // 好人胜利
                endGame('good');
                return true;
            } else if (gameState.wolfCount >= gameState.villagerCount) {
                // 狼人胜利
                endGame('wolf');
                return true;
            }
            
            return false;
        }

        // 结束游戏
        function endGame(winner) {
            gameState.gamePhase = 'game_over';
            gameState.winningTeam = winner;
            
            // 显示结果弹窗
            showResultModal(winner);
            
            // 更新游戏阶段显示
            updateGamePhaseUI();
            
            // 如果是房主，广播游戏结束
            if (gameState.isHost) {
                // 获取所有玩家的角色信息
                const roles = gameState.players.map(player => ({
                    id: player.id,
                    name: player.name,
                    role: player.role
                }));
                
                // 广播游戏结束
                Object.values(gameState.connections).forEach(conn => {
                    conn.send({
                        type: 'game_action',
                        action: 'game_over',
                        data: {
                            winner: winner,
                            roles: roles
                        }
                    });
                });
            }
        }

        // 显示结果弹窗
        function showResultModal(winner) {
            const title = document.getElementById('result-title');
            const content = document.getElementById('result-content');
            
            // 设置标题
            if (winner === 'good') {
                title.textContent = '好人阵营胜利！';
                title.className = 'text-2xl font-bold mb-4 text-villager';
            } else {
                title.textContent = '狼人阵营胜利！';
                title.className = 'text-2xl font-bold mb-4 text-wolf';
            }
            
            // 生成玩家角色列表
            let rolesHtml = '<div class="mb-4">玩家角色：</div>';
            rolesHtml += '<div class="grid grid-cols-1 md:grid-cols-2 gap-2">';
            
            gameState.players.forEach(player => {
                const isAlive = !gameState.deadPlayers.includes(player.id);
                const roleName = ROLE_NAMES[player.role] || '未知';
                const roleIcon = ROLE_ICONS[player.role] || '❓';
                
                rolesHtml += `
                    <div class="flex items-center ${isAlive ? '' : 'text-gray-500 dark:text-gray-400'}">
                        <span class="inline-block w-6 text-center">${roleIcon}</span>
                        <span class="font-medium ml-2">${player.name}</span>
                        <span class="ml-auto">${roleName}</span>
                    </div>
                `;
            });
            
            rolesHtml += '</div>';
            content.innerHTML = rolesHtml;
            
            // 显示弹窗
            showModal('result-modal');
        }

        // 添加聊天消息
        function addChatMessage(playerName, text, playerId = null) {
            const messagesContainer = document.getElementById('chat-messages');
            const messageElement = document.createElement('div');
            messageElement.className = 'mb-2';
            
            const isYou = playerId === gameState.peer.id;
            const isDead = gameState.deadPlayers.includes(playerId);
            
            // 添加名字和消息内容
            messageElement.innerHTML = `
                <div class="flex items-start">
                    <span class="font-medium ${isDead ? 'text-gray-500 dark:text-gray-400' : ''}">${playerName}${isYou ? ' (你)' : ''}:</span>
                    <span class="ml-1 break-words ${isDead ? 'text-gray-500 dark:text-gray-400' : ''}">${text}</span>
                </div>
            `;
            
            messagesContainer.appendChild(messageElement);
            messagesContainer.scrollTop = messagesContainer.scrollHeight;
        }

        // 发送聊天消息
        function sendChatMessage() {
            const input = document.getElementById('chat-input');
            const text = input.value.trim();
            
            if (!text) return;
            
            // 检查是否可以发言
            if (gameState.gamePhase === 'night') {
                alert('夜晚无法发言');
                return;
            }
            
            // 检查是否活着
            if (gameState.deadPlayers.includes(gameState.peer.id) && !gameState.spectators.includes(gameState.peer.id)) {
                alert('你已经死亡，无法发言');
                return;
            }
            
            // 检查发言轮次
            if (gameState.gamePhase === 'speaking' && gameState.currentSpeaker !== gameState.peer.id) {
                alert('现在不是你的发言轮次');
                return;
            }
            
            // 添加到本地聊天
            addChatMessage(gameState.playerName, text, gameState.peer.id);
            
            // 清空输入框
            input.value = '';
            
            // 广播聊天消息
            broadcastChatMessage(gameState.peer.id, gameState.playerName, text);
        }

        // 广播聊天消息给所有玩家
        function broadcastChatMessage(playerId, playerName, text) {
            Object.values(gameState.connections).forEach(conn => {
                conn.send({
                    type: 'chat_message',
                    playerName: playerName,
                    playerId: playerId,
                    text: text
                });
            });
        }

        // 添加游戏日志
        function addToGameLog(text, type = 'normal') {
            const logContainer = document.getElementById('game-log');
            const logElement = document.createElement('p');
            
            switch (type) {
                case 'highlight':
                    logElement.className = 'text-primary dark:text-primary';
                    break;
                case 'warning':
                    logElement.className = 'text-orange-600 dark:text-orange-400';
                    break;
                case 'error':
                    logElement.className = 'text-red-600 dark:text-red-400';
                    break;
                case 'success':
                    logElement.className = 'text-green-600 dark:text-green-400';
                    break;
                default:
                    logElement.className = '';
            }
            
            logElement.textContent = text;
            logContainer.appendChild(logElement);
            
            // 自动滚动到底部
            logContainer.scrollTop = logContainer.scrollHeight;
        }

        // 广播游戏日志给所有玩家
        function broadcastGameLog(text) {
            Object.values(gameState.connections).forEach(conn => {
                conn.send({
                    type: 'game_log',
                    text: text
                });
            });
            
            // 同时添加到本地日志
            addToGameLog(text);
        }

        // 退出房间
        function leaveRoom() {
            // 关闭所有连接
            Object.values(gameState.connections).forEach(conn => {
                conn.close();
            });
            
            // 重置游戏状态
            gameState.connections = {};
            gameState.players = [];
            gameState.aiPlayers = [];
            gameState.roomCode = null;
            gameState.isHost = false;
            gameState.gameStarted = false;
            gameState.gamePhase = 'waiting';
            gameState.day = 0;
            gameState.deadPlayers = [];
            gameState.inited = false;
            
            // 返回欢迎屏幕
            showScreen('welcome-screen');
        }

        // 退出游戏
        function quitGame() {
            // 确认是否要退出
            if (!confirm('确定要退出游戏吗？')) {
                return;
            }
            
            hideModal('menu-modal');
            leaveRoom();
        }

        // 返回主菜单
        function backToMainMenu() {
            hideModal('result-modal');
            leaveRoom();
        }

        // 复制房间代码
        function copyRoomCode() {
            const roomCode = document.getElementById('display-room-code').textContent;
            
            navigator.clipboard.writeText(roomCode).then(() => {
                alert('房间代码已复制到剪贴板');
            }).catch(err => {
                console.error('复制失败:', err);
                // 提示手动复制
                alert('请手动复制房间代码: ' + roomCode);
            });
        }

        // 显示/隐藏角色卡片
        function toggleRoleCard() {
            const roleCard = document.getElementById('player-role-card');
            roleCard.classList.toggle('flipped');
            
            const description = document.getElementById('role-description');
            const viewBtn = document.getElementById('view-role-btn');
            
            if (roleCard.classList.contains('flipped')) {
                viewBtn.textContent = '隐藏角色';
                description.classList.remove('hidden');
            } else {
                viewBtn.textContent = '查看角色';
                description.classList.add('hidden');
            }
        }

        // 事件监听器
        document.addEventListener('DOMContentLoaded', async () => {
            // 初始化Peer连接
            try {
                await initPeer();
                console.log('P2P初始化成功');
            } catch (error) {
                console.error('P2P初始化失败:', error);
                alert('连接错误: ' + error.message);
            }
            
            // 角色配置变更监听
            document.querySelectorAll('#role-wolf, #role-wolf-king, #role-secret-wolf, #role-villager, #role-witch, #role-hunter, #role-guard, #role-seer, #role-idiot').forEach(input => {
                input.addEventListener('change', updateRoleCountWarning);
            });
            
            // 玩家人数变更监听
            document.getElementById('player-count').addEventListener('change', updateRoleCountWarning);
            
            // 推荐配置按钮
            document.getElementById('recommended-setup-btn').addEventListener('click', applyRecommendedSetup);
            
            // 创建房间按钮
            document.getElementById('create-room-btn').addEventListener('click', createRoom);
            
            // 加入房间按钮
            document.getElementById('join-room-btn').addEventListener('click', joinRoom);
            
            // 返回按钮
            document.getElementById('back-to-welcome-btn').addEventListener('click', () => showScreen('welcome-screen'));
            document.getElementById('leave-room-btn').addEventListener('click', leaveRoom);
            
            // 复制房间代码按钮
            document.getElementById('copy-code-btn').addEventListener('click', copyRoomCode);
            
            // 开始游戏按钮
            document.getElementById('start-game-btn').addEventListener('click', startGame);
            
            // 添加AI玩家按钮
            document.getElementById('add-ai-btn').addEventListener('click', showAddAIModal);
            document.getElementById('confirm-add-ai-btn').addEventListener('click', addAIPlayer);
            document.getElementById('cancel-add-ai-btn').addEventListener('click', () => hideModal('add-ai-modal'));
            
            // 游戏菜单按钮
            document.getElementById('game-menu-btn').addEventListener('click', () => showModal('menu-modal'));
            document.getElementById('resume-game-btn').addEventListener('click', () => hideModal('menu-modal'));
            document.getElementById('quit-game-btn').addEventListener('click', quitGame);
            
            // 继续游戏/新游戏按钮
            document.getElementById('new-game-btn').addEventListener('click', backToMainMenu);
            
            // 角色卡片按钮
            document.getElementById('view-role-btn').addEventListener('click', toggleRoleCard);
            
            // 聊天发送按钮
            document.getElementById('send-chat-btn').addEventListener('click', sendChatMessage);
            document.getElementById('chat-input').addEventListener('keypress', event => {
                if (event.key === 'Enter') {
                    sendChatMessage();
                }
            });
            
            // 下一位发言按钮
            document.getElementById('next-speaker-btn').addEventListener('click', () => {
                if (gameState.isHost || gameState.currentSpeaker === gameState.peer.id) {
                    // 如果是房主或当前发言人
                    if (gameState.isHost) {
                        endCurrentSpeech();
                    } else {
                        // 发送给房主，结束自己的发言
                        const hostId = gameState.players.find(p => p.isHost)?.id;
                        if (hostId && gameState.connections[hostId]) {
                            gameState.connections[hostId].send({
                                type: 'game_action',
                                action: 'end_speech',
                                data: {
                                    speakerId: gameState.peer.id
                                }
                            });
                        }
                    }
                }
            });
            
            // 投票按钮
            document.getElementById('confirm-vote-btn').addEventListener('click', submitVote);
            document.getElementById('skip-vote-btn').addEventListener('click', skipVote);
        });
    </script>
</body>
</html>
